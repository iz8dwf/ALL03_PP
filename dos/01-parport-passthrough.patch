diff --git a/Makefile.in b/Makefile.in
index d2f8d4e..413b5eb 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -230,6 +230,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/compile b/compile
old mode 100755
new mode 100644
diff --git a/config.h.in b/config.h.in
index 54fc105..c479914 100644
--- a/config.h.in
+++ b/config.h.in
@@ -38,6 +38,9 @@
 /* Define to 1 to enable internal debugger, requires libcurses */
 #undef C_DEBUG
 
+/* Define to 1 if you want parallel passthrough support (Win32, Linux). */
+#undef C_DIRECTLPT
+
 /* Define to 1 if you want serial passthrough support (Win32, Posix and OS/2).
    */
 #undef C_DIRECTSERIAL
@@ -77,6 +80,9 @@
 /* Define to 1 to use opengl display output support */
 #undef C_OPENGL
 
+/* Define to 1 to use printer support */
+#undef C_PRINTER
+
 /* Define to 1 to enable SDL_sound support */
 #undef C_SDL_SOUND
 
diff --git a/configure b/configure
index cbc6e19..538452e 100755
--- a/configure
+++ b/configure
@@ -626,6 +626,7 @@ LIBOBJS
 HAVE_WINDRES_FALSE
 HAVE_WINDRES_TRUE
 WINDRES
+FREETYPE_CONFIG
 ALSA_LIBS
 ALSA_CFLAGS
 EGREP
@@ -752,6 +753,7 @@ enable_dynrec
 enable_fpu
 enable_fpu_x86
 enable_unaligned_memory
+enable_printer
 enable_opengl
 '
       ac_precious_vars='build_alias
@@ -1413,6 +1415,7 @@ Optional Features:
   --disable-fpu-x86       Disable x86 assembly fpu core
   --disable-unaligned-memory
                           Disable unaligned memory access
+  --disable-printer       Disable printer support
   --disable-opengl        Disable opengl support
 
 Optional Packages:
@@ -6993,6 +6996,65 @@ $as_echo "$as_me: WARNING: Can't find libpng, screenshot support disabled" >&2;}
 fi
 
 
+# Check whether --enable-printer was given.
+if test "${enable_printer+set}" = set; then :
+  enableval=$enable_printer;
+else
+  enable_printer=yes
+fi
+
+# Extract the first word of "freetype-config", so it can be a program name with args.
+set dummy freetype-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_FREETYPE_CONFIG+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $FREETYPE_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_FREETYPE_CONFIG="$FREETYPE_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_FREETYPE_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_FREETYPE_CONFIG" && ac_cv_path_FREETYPE_CONFIG="no"
+  ;;
+esac
+fi
+FREETYPE_CONFIG=$ac_cv_path_FREETYPE_CONFIG
+if test -n "$FREETYPE_CONFIG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $FREETYPE_CONFIG" >&5
+$as_echo "$FREETYPE_CONFIG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+if test "$FREETYPE_CONFIG" = "no" ; then
+   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Can't find FreeType2, printer disabled" >&5
+$as_echo "$as_me: WARNING: Can't find FreeType2, printer disabled" >&2;}
+else
+    $as_echo "#define C_PRINTER 1" >>confdefs.h
+
+    CXXFLAGS="$CXXFLAGS `$FREETYPE_CONFIG --cflags`"
+    LIBS="$LIBS `$FREETYPE_CONFIG --libs`"
+fi
+
+
 
 ac_fn_c_check_header_mongrel "$LINENO" "SDL_net.h" "ac_cv_header_SDL_net_h" "$ac_includes_default"
 if test "x$ac_cv_header_SDL_net_h" = xyes; then :
@@ -7421,6 +7483,9 @@ done
 
 $as_echo "#define C_DIRECTSERIAL 1" >>confdefs.h
 
+
+$as_echo "#define C_DIRECTLPT 1" >>confdefs.h
+
        if test x$have_sdl_net_lib = xyes -a x$have_sdl_net_h = xyes ; then
          LIBS="$LIBS -lws2_32"
        fi
@@ -7441,6 +7506,9 @@ $as_echo "#define LINUX 1" >>confdefs.h
 
 $as_echo "#define C_DIRECTSERIAL 1" >>confdefs.h
 
+
+$as_echo "#define C_DIRECTLPT 1" >>confdefs.h
+
        ;;
     *-*-freebsd* | *-*-dragonfly* | *-*-netbsd* | *-*-openbsd*)
 
@@ -7570,7 +7638,7 @@ fi
 
 
 
-ac_config_files="$ac_config_files Makefile src/Makefile src/cpu/Makefile src/cpu/core_full/Makefile src/cpu/core_normal/Makefile src/cpu/core_dyn_x86/Makefile src/cpu/core_dynrec/Makefile src/debug/Makefile src/dos/Makefile src/fpu/Makefile src/gui/Makefile src/hardware/Makefile src/hardware/mame/Makefile src/hardware/serialport/Makefile src/ints/Makefile src/libs/Makefile src/libs/zmbv/Makefile src/libs/gui_tk/Makefile src/misc/Makefile src/shell/Makefile src/platform/Makefile src/platform/visualc/Makefile visualc_net/Makefile include/Makefile docs/Makefile"
+ac_config_files="$ac_config_files Makefile src/Makefile src/cpu/Makefile src/cpu/core_full/Makefile src/cpu/core_normal/Makefile src/cpu/core_dyn_x86/Makefile src/cpu/core_dynrec/Makefile src/debug/Makefile src/dos/Makefile src/fpu/Makefile src/gui/Makefile src/hardware/Makefile src/hardware/mame/Makefile src/hardware/serialport/Makefile src/hardware/parport/Makefile src/ints/Makefile src/libs/Makefile src/libs/zmbv/Makefile src/libs/gui_tk/Makefile src/libs/porttalk/Makefile src/misc/Makefile src/shell/Makefile src/platform/Makefile src/platform/visualc/Makefile visualc_net/Makefile include/Makefile docs/Makefile"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -8322,10 +8390,12 @@ do
     "src/hardware/Makefile") CONFIG_FILES="$CONFIG_FILES src/hardware/Makefile" ;;
     "src/hardware/mame/Makefile") CONFIG_FILES="$CONFIG_FILES src/hardware/mame/Makefile" ;;
     "src/hardware/serialport/Makefile") CONFIG_FILES="$CONFIG_FILES src/hardware/serialport/Makefile" ;;
+    "src/hardware/parport/Makefile") CONFIG_FILES="$CONFIG_FILES src/hardware/parport/Makefile" ;;
     "src/ints/Makefile") CONFIG_FILES="$CONFIG_FILES src/ints/Makefile" ;;
     "src/libs/Makefile") CONFIG_FILES="$CONFIG_FILES src/libs/Makefile" ;;
     "src/libs/zmbv/Makefile") CONFIG_FILES="$CONFIG_FILES src/libs/zmbv/Makefile" ;;
     "src/libs/gui_tk/Makefile") CONFIG_FILES="$CONFIG_FILES src/libs/gui_tk/Makefile" ;;
+    "src/libs/porttalk/Makefile") CONFIG_FILES="$CONFIG_FILES src/libs/porttalk/Makefile" ;;
     "src/misc/Makefile") CONFIG_FILES="$CONFIG_FILES src/misc/Makefile" ;;
     "src/shell/Makefile") CONFIG_FILES="$CONFIG_FILES src/shell/Makefile" ;;
     "src/platform/Makefile") CONFIG_FILES="$CONFIG_FILES src/platform/Makefile" ;;
diff --git a/configure.ac b/configure.ac
index a723222..645e92d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -395,6 +395,17 @@ else
   AC_MSG_WARN([Can't find libpng, screenshot support disabled])
 fi
 
+AH_TEMPLATE(C_PRINTER,[Define to 1 to use printer support])
+AC_ARG_ENABLE(printer,AC_HELP_STRING([--disable-printer],[Disable printer support]),,enable_printer=yes)
+AC_PATH_PROG(FREETYPE_CONFIG, freetype-config, no)
+if test "$FREETYPE_CONFIG" = "no" ; then
+   AC_MSG_WARN([Can't find FreeType2, printer disabled])
+else
+    AC_DEFINE(C_PRINTER,1)
+    CXXFLAGS="$CXXFLAGS `$FREETYPE_CONFIG --cflags`"
+    LIBS="$LIBS `$FREETYPE_CONFIG --libs`"
+fi
+
 AH_TEMPLATE(C_MODEM,[Define to 1 to enable internal modem support, requires SDL_net])
 AH_TEMPLATE(C_IPX,[Define to 1 to enable IPX over Internet networking, requires SDL_net])
 AC_CHECK_HEADER(SDL_net.h,have_sdl_net_h=yes,)
@@ -499,6 +510,7 @@ case "$host" in
        LIBS="$LIBS -lwinmm"
        AC_CHECK_HEADERS(ddraw.h)
        AC_DEFINE(C_DIRECTSERIAL, 1, [ Define to 1 if you want serial passthrough support (Win32, Posix and OS/2 only).])
+       AC_DEFINE(C_DIRECTLPT, 1, [ Define to 1 if you want parallel passthrough support (Win32 only).])
        if test x$have_sdl_net_lib = xyes -a x$have_sdl_net_h = xyes ; then
          LIBS="$LIBS -lws2_32"
        fi
@@ -515,6 +527,7 @@ case "$host" in
     *-*-linux*)
        AC_DEFINE(LINUX, 1, [Compiling on GNU/Linux])
        AC_DEFINE(C_DIRECTSERIAL, 1, [ Define to 1 if you want serial passthrough support (Win32, Posix and OS/2).])
+       AC_DEFINE(C_DIRECTLPT, 1, [ Define to 1 if you want parallel passthrough support (Win32, Linux).])
        ;;
     *-*-freebsd* | *-*-dragonfly* | *-*-netbsd* | *-*-openbsd*)
        dnl Disabled directserial for now. It doesn't do anything without
@@ -560,10 +573,12 @@ src/gui/Makefile
 src/hardware/Makefile
 src/hardware/mame/Makefile
 src/hardware/serialport/Makefile
+src/hardware/parport/Makefile
 src/ints/Makefile
 src/libs/Makefile
 src/libs/zmbv/Makefile
 src/libs/gui_tk/Makefile
+src/libs/porttalk/Makefile
 src/misc/Makefile
 src/shell/Makefile
 src/platform/Makefile
diff --git a/docs/Makefile.in b/docs/Makefile.in
index b494274..3fb6264 100644
--- a/docs/Makefile.in
+++ b/docs/Makefile.in
@@ -178,6 +178,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/include/Makefile.am b/include/Makefile.am
index b37389c..8f64ba4 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -23,6 +23,7 @@ mem.h \
 mixer.h \
 modules.h \
 mouse.h \
+parport.h \
 paging.h \
 pic.h \
 programs.h \
diff --git a/include/Makefile.in b/include/Makefile.in
index a2dde67..3b9e02c 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -166,6 +166,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -273,6 +274,7 @@ mem.h \
 mixer.h \
 modules.h \
 mouse.h \
+parport.h \
 paging.h \
 pic.h \
 programs.h \
diff --git a/include/bios.h b/include/bios.h
index 8f722d6..7d38c28 100644
--- a/include/bios.h
+++ b/include/bios.h
@@ -129,5 +129,6 @@ bool BIOS_AddKeyToBuffer(Bit16u code);
 void INT10_ReloadRomFonts();
 
 void BIOS_SetComPorts (Bit16u baseaddr[]);
+void BIOS_SetLPTPort (Bitu port, Bit16u baseaddr);
 
 #endif
diff --git a/include/parport.h b/include/parport.h
new file mode 100644
index 0000000..2d1eb9e
--- /dev/null
+++ b/include/parport.h
@@ -0,0 +1,109 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef DOSBOX_PARPORT_H
+#define DOSBOX_PARPORT_H
+
+// set to 1 for debug messages and debugging log:
+#define PARALLEL_DEBUG 0
+
+#ifndef DOSBOX_DOSBOX_H
+#include "dosbox.h"
+#endif
+#ifndef DOSBOX_INOUT_H
+#include "inout.h"
+#endif
+
+#include "control.h"
+#include "dos_inc.h"
+
+class device_LPT : public DOS_Device {
+public:
+	// Creates a LPT device that communicates with the num-th parallel port, i.e. is LPTnum
+	device_LPT(Bit8u num, class CParallel* pp);
+	~device_LPT();
+	bool Read(Bit8u * data,Bit16u * size);
+	bool Write(Bit8u * data,Bit16u * size);
+	bool Seek(Bit32u * pos,Bit32u type);
+	bool Close();
+	Bit16u GetInformation(void);
+private:
+	CParallel* pportclass;
+	Bit8u num; // This device is LPTnum
+};
+
+
+class CParallel {
+public:
+#if PARALLEL_DEBUG
+	FILE * debugfp;
+	bool dbg_data;
+	bool dbg_putchar;
+	bool dbg_cregs;
+	bool dbg_plainputchar;
+	bool dbg_plaindr;
+	void log_par(bool active, char const* format,...);
+#endif
+
+	// Constructor
+	CParallel(CommandLine* cmd, Bitu portnr, Bit8u initirq);
+	
+	virtual ~CParallel();
+
+	IO_ReadHandleObject ReadHandler[3];
+	IO_WriteHandleObject WriteHandler[3];
+
+	void setEvent(Bit16u type, float duration);
+	void removeEvent(Bit16u type);
+	void handleEvent(Bit16u type);
+	virtual void handleUpperEvent(Bit16u type)=0;
+	
+	Bitu port_nr;
+	Bitu base;
+	Bitu irq;
+	
+	// read data line register
+	virtual Bitu Read_PR()=0;
+	virtual Bitu Read_COM()=0;
+	virtual Bitu Read_SR()=0;
+
+	virtual void Write_PR(Bitu)=0;
+	virtual void Write_CON(Bitu)=0;
+	virtual void Write_IOSEL(Bitu)=0;
+
+	void Write_reserved(Bit8u data, Bit8u address);
+
+	virtual bool Putchar(Bit8u)=0;
+	bool Putchar_default(Bit8u);
+	Bit8u getPrinterStatus();
+	void initialize();
+	
+
+
+private:
+	 DOS_Device* mydosdevice;
+		
+};
+
+extern CParallel* parallelPortObjects[];
+void PARALLEL_Init (Section * sec);
+
+const Bit16u parallel_baseaddr[3] = {0x378,0x278,0x3bc};
+
+#endif
+
diff --git a/src/Makefile.am b/src/Makefile.am
index a4029e8..ca27142 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -14,7 +14,8 @@ endif
 dosbox_SOURCES = dosbox.cpp $(ico_stuff)
 dosbox_LDADD = cpu/libcpu.a debug/libdebug.a dos/libdos.a fpu/libfpu.a  hardware/libhardware.a gui/libgui.a \
                ints/libints.a misc/libmisc.a shell/libshell.a hardware/mame/libmame.a \
-               hardware/serialport/libserial.a libs/gui_tk/libgui_tk.a
+               hardware/serialport/libserial.a hardware/parport/libparallel.a \
+               libs/gui_tk/libgui_tk.a libs/porttalk/libporttalk.a
 
 EXTRA_DIST = winres.rc dosbox.ico
 
diff --git a/src/Makefile.in b/src/Makefile.in
index 92e9428..4ba8584 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -110,7 +110,8 @@ dosbox_DEPENDENCIES = cpu/libcpu.a debug/libdebug.a dos/libdos.a \
 	fpu/libfpu.a hardware/libhardware.a gui/libgui.a \
 	ints/libints.a misc/libmisc.a shell/libshell.a \
 	hardware/mame/libmame.a hardware/serialport/libserial.a \
-	libs/gui_tk/libgui_tk.a
+	hardware/parport/libparallel.a libs/gui_tk/libgui_tk.a \
+	libs/porttalk/libporttalk.a
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
 am__v_P_0 = false
@@ -235,6 +236,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -323,7 +325,8 @@ SUBDIRS = cpu debug dos fpu gui hardware libs ints misc shell platform
 dosbox_SOURCES = dosbox.cpp $(ico_stuff)
 dosbox_LDADD = cpu/libcpu.a debug/libdebug.a dos/libdos.a fpu/libfpu.a  hardware/libhardware.a gui/libgui.a \
                ints/libints.a misc/libmisc.a shell/libshell.a hardware/mame/libmame.a \
-               hardware/serialport/libserial.a libs/gui_tk/libgui_tk.a
+               hardware/serialport/libserial.a hardware/parport/libparallel.a \
+               libs/gui_tk/libgui_tk.a libs/porttalk/libporttalk.a
 
 EXTRA_DIST = winres.rc dosbox.ico
 all: all-recursive
diff --git a/src/cpu/Makefile.in b/src/cpu/Makefile.in
index 0013e3a..cc2dcce 100644
--- a/src/cpu/Makefile.in
+++ b/src/cpu/Makefile.in
@@ -250,6 +250,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/cpu/core_dyn_x86/Makefile.in b/src/cpu/core_dyn_x86/Makefile.in
index 3733904..b57d650 100644
--- a/src/cpu/core_dyn_x86/Makefile.in
+++ b/src/cpu/core_dyn_x86/Makefile.in
@@ -166,6 +166,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/cpu/core_dynrec/Makefile.in b/src/cpu/core_dynrec/Makefile.in
index 591c10a..6777de1 100644
--- a/src/cpu/core_dynrec/Makefile.in
+++ b/src/cpu/core_dynrec/Makefile.in
@@ -166,6 +166,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/cpu/core_full/Makefile.in b/src/cpu/core_full/Makefile.in
index 7652fee..95ca0f0 100644
--- a/src/cpu/core_full/Makefile.in
+++ b/src/cpu/core_full/Makefile.in
@@ -166,6 +166,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/cpu/core_normal/Makefile.in b/src/cpu/core_normal/Makefile.in
index 2084352..5255b7a 100644
--- a/src/cpu/core_normal/Makefile.in
+++ b/src/cpu/core_normal/Makefile.in
@@ -166,6 +166,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/debug/Makefile.in b/src/debug/Makefile.in
index 0d975c1..b532e2f 100644
--- a/src/debug/Makefile.in
+++ b/src/debug/Makefile.in
@@ -205,6 +205,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/dos/Makefile.in b/src/dos/Makefile.in
index 8863c5c..1048c7f 100644
--- a/src/dos/Makefile.in
+++ b/src/dos/Makefile.in
@@ -213,6 +213,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/dos/dos.cpp b/src/dos/dos.cpp
index 35eb73e..4ef2a9a 100644
--- a/src/dos/dos.cpp
+++ b/src/dos/dos.cpp
@@ -30,6 +30,7 @@
 #include "dos_inc.h"
 #include "setup.h"
 #include "support.h"
+#include "parport.h"
 #include "serialport.h"
 
 DOS_Block dos;
@@ -132,8 +133,16 @@ static Bitu DOS_21Handler(void) {
 		}
 		break;
 	case 0x05:		/* Write Character to PRINTER */
-		E_Exit("DOS:Unhandled call %02X",reg_ah);
+	{
+		for(int i = 0; i < 3; i++) {
+			// look up a parallel port
+			if(parallelPortObjects[i] != NULL) {
+				parallelPortObjects[i]->Putchar(reg_dl);
+				break;
+			}
+		}
 		break;
+	}
 	case 0x06:		/* Direct Console Output / Input */
 		switch (reg_dl) {
 		case 0xFF:	/* Input */
diff --git a/src/dos/dos_devices.cpp b/src/dos/dos_devices.cpp
index 26fb0b4..760ce3a 100644
--- a/src/dos/dos_devices.cpp
+++ b/src/dos/dos_devices.cpp
@@ -26,6 +26,7 @@
 #include "bios.h"
 #include "dos_inc.h"
 #include "support.h"
+#include "parport.h"
 #include "drives.h" //Wildcmp
 /* Include all the devices */
 
@@ -57,10 +58,39 @@ public:
 	virtual bool WriteToControlChannel(PhysPt bufptr,Bit16u size,Bit16u * retcode){return false;}
 };
 
-class device_LPT1 : public device_NUL {
+class device_PRN : public DOS_Device {
 public:
-   	device_LPT1() { SetName("LPT1");}
-	Bit16u GetInformation(void) { return 0x80A0; }
+	device_PRN() {
+		SetName("PRN");
+	}
+	bool Read(Bit8u * data,Bit16u * size) {
+		*size=0;
+		LOG(LOG_DOSMISC,LOG_NORMAL)("PRNDEVICE:Read called");
+		return true;
+	}
+	bool Write(Bit8u * data,Bit16u * size) {
+		for(int i = 0; i < 3; i++) {
+			// look up a parallel port
+			if(parallelPortObjects[i] != NULL) {
+				// send the data
+				for (Bit16u j=0; j<*size; j++) {
+					if(!parallelPortObjects[i]->Putchar(data[j])) return false;
+				}
+				return true;
+			}
+		}
+		return false;
+	}
+	bool Seek(Bit32u * pos,Bit32u type) {
+		*pos = 0;
+		return true;
+	}
+	Bit16u GetInformation(void) {
+		return 0x80A0;
+	}
+	bool Close() {
+		return false;
+	}
 };
 
 bool DOS_Device::Read(Bit8u * data,Bit16u * size) {
@@ -189,6 +219,6 @@ void DOS_SetupDevices(void) {
 	newdev2=new device_NUL();
 	DOS_AddDevice(newdev2);
 	DOS_Device * newdev3;
-	newdev3=new device_LPT1();
+	newdev3=new device_PRN();
 	DOS_AddDevice(newdev3);
 }
diff --git a/src/dosbox.cpp b/src/dosbox.cpp
index edee31a..d70e02c 100644
--- a/src/dosbox.cpp
+++ b/src/dosbox.cpp
@@ -42,6 +42,7 @@
 #include "mapper.h"
 #include "ints/int10.h"
 #include "render.h"
+#include "parport.h"
 
 Config * control;
 MachineType machine;
@@ -86,6 +87,9 @@ void TANDYSOUND_Init(Section*);
 void DISNEY_Init(Section*);
 void SERIAL_Init(Section*); 
 
+#if C_PRINTER
+void PRINTER_Init(Section*);
+#endif
 
 #if C_IPX
 void IPX_Init(Section*);
@@ -724,6 +728,77 @@ void DOSBOX_Init(void) {
 	Pstring = Pmulti_remain->GetSection()->Add_string("parameters",Property::Changeable::WhenIdle,"");
 	Pmulti_remain->Set_help("see serial1");
 
+#if C_PRINTER
+	secprop=control->AddSection_prop("printer",&PRINTER_Init);
+	Pbool = secprop->Add_bool("printer",Property::Changeable::WhenIdle,true);
+	Pbool->Set_help("Enable printer emulation.");
+	//secprop->Add_string("fontpath","%%windir%%\\fonts");
+	Pint = secprop->Add_int("dpi",Property::Changeable::WhenIdle,360);
+	Pint->Set_help("Resolution of printer (default 360).");
+	Pint = secprop->Add_int("width",Property::Changeable::WhenIdle,85);
+	Pint->Set_help("Width of paper in 1/10 inch (default 85 = 8.5'').");
+	Pint = secprop->Add_int("height",Property::Changeable::WhenIdle,110);
+	Pint->Set_help("Height of paper in 1/10 inch (default 110 = 11.0'').");
+#ifdef C_LIBPNG
+	Pstring = secprop->Add_string("printoutput",Property::Changeable::WhenIdle, "png");
+#else
+	Pstring = secprop->Add_string("printoutput",Property::Changeable::WhenIdle, "ps");
+#endif
+	Pstring->Set_help("Output method for finished pages: \n"
+#ifdef C_LIBPNG
+		"  png     : Creates PNG images (default)\n"
+#endif
+		"  ps      : Creates Postscript\n"
+		"  bmp     : Creates BMP images (very huge files, not recommend)\n"
+#if defined (WIN32)
+		"  printer : Send to an actual printer (Print dialog will appear)"
+#endif
+		);
+
+	Pbool = secprop->Add_bool("multipage",Property::Changeable::WhenIdle, false);
+	Pbool->Set_help("Adds all pages to one Postscript file or printer job until CTRL-F2 is pressed.");
+
+	Pstring = secprop->Add_string("docpath",Property::Changeable::WhenIdle,".");
+	Pstring->Set_help("The path where the output files are stored.");
+
+	Pint = secprop->Add_int("timeout",Property::Changeable::WhenIdle,0);
+	Pint->Set_help("(in milliseconds) if nonzero: the time the page will\n"
+					"be ejected automatically after when no more data\n"
+					"arrives at the printer.");
+#endif
+
+	// parallel ports
+	secprop=control->AddSection_prop("parallel",&PARALLEL_Init,true);
+	Pstring = secprop->Add_string("parallel1",Property::Changeable::WhenIdle,"disabled");
+	Pstring->Set_help(
+	        "parallel1-3 -- set type of device connected to lpt port.\n"
+			"Can be:\n"
+			"	reallpt (direct parallel port passthrough using Porttalk),\n"
+			"	file (records data to a file or passes it to a device),\n"
+			"	printer (virtual dot-matrix printer, see [printer] section)\n"
+	        "Additional parameters must be in the same line in the form of\n"
+	        "parameter:value.\n"
+	        "  for reallpt:\n"
+	        "  Windows:\n"
+			"    realbase (the base address of your real parallel port).\n"
+			"      Default: 378\n"
+			"    ecpbase (base address of the ECP registers, optional).\n"
+			"  Linux: realport (the parallel port device i.e. /dev/parport0).\n"
+			"  for file: \n"
+			"    dev:<devname> (i.e. dev:lpt1) to forward data to a device,\n"
+			"    or append:<file> appends data to the specified file.\n"
+			"    Without the above parameters data is written to files in the capture dir.\n"
+			"    Additional parameters: timeout:<milliseconds> = how long to wait before\n"
+			"    closing the file on inactivity (default:500), addFF to add a formfeed when\n"
+			"    closing, addLF to add a linefeed if the app doesn't, cp:<codepage number>\n"
+			"    to perform codepage translation, i.e. cp:437\n"
+			"  for printer:\n"
+			"    printer still has it's own configuration section above."
+	);
+	Pstring = secprop->Add_string("parallel2",Property::Changeable::WhenIdle,"disabled");
+	Pstring->Set_help("see parallel1");
+	Pstring = secprop->Add_string("parallel3",Property::Changeable::WhenIdle,"disabled");
+	Pstring->Set_help("see parallel1");
 
 	/* All the DOS Related stuff, which will eventually start up in the shell */
 	secprop=control->AddSection_prop("dos",&DOS_Init,false);//done
diff --git a/src/fpu/Makefile.in b/src/fpu/Makefile.in
index eb1ff2b..7358c28 100644
--- a/src/fpu/Makefile.in
+++ b/src/fpu/Makefile.in
@@ -204,6 +204,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/gui/Makefile.in b/src/gui/Makefile.in
index de062f5..e2f3b0c 100644
--- a/src/gui/Makefile.in
+++ b/src/gui/Makefile.in
@@ -206,6 +206,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/hardware/Makefile.am b/src/hardware/Makefile.am
index 2c3c3a6..7319c27 100644
--- a/src/hardware/Makefile.am
+++ b/src/hardware/Makefile.am
@@ -1,6 +1,6 @@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 
-SUBDIRS = serialport mame
+SUBDIRS = serialport parport mame
 
 EXTRA_DIST = opl.cpp opl.h adlib.h dbopl.h
 
diff --git a/src/hardware/Makefile.in b/src/hardware/Makefile.in
index f4bff67..67abdf4 100644
--- a/src/hardware/Makefile.in
+++ b/src/hardware/Makefile.in
@@ -245,6 +245,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -328,7 +329,7 @@ top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
-SUBDIRS = serialport mame
+SUBDIRS = serialport parport mame
 EXTRA_DIST = opl.cpp opl.h adlib.h dbopl.h
 noinst_LIBRARIES = libhardware.a
 libhardware_a_SOURCES = adlib.cpp dma.cpp gameblaster.cpp hardware.cpp iohandler.cpp joystick.cpp keyboard.cpp \
diff --git a/src/hardware/mame/Makefile.in b/src/hardware/mame/Makefile.in
index c8cd604..5ead077 100644
--- a/src/hardware/mame/Makefile.in
+++ b/src/hardware/mame/Makefile.in
@@ -204,6 +204,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/hardware/parport/Makefile.am b/src/hardware/parport/Makefile.am
new file mode 100644
index 0000000..026eb41
--- /dev/null
+++ b/src/hardware/parport/Makefile.am
@@ -0,0 +1,11 @@
+AM_CPPFLAGS = -I$(top_srcdir)/include
+
+noinst_LIBRARIES = libparallel.a
+
+libparallel_a_SOURCES = parport.cpp \
+			directlpt_win32.cpp directlpt_win32.h \
+			directlpt_linux.cpp directlpt_linux.h \
+			printer_redir.cpp printer_redir.h printer_if.h \
+			printer.cpp printer.h \
+			printer_charmaps.cpp printer_charmaps.h \
+			filelpt.cpp filelpt.h
diff --git a/src/hardware/parport/Makefile.in b/src/hardware/parport/Makefile.in
new file mode 100644
index 0000000..de39444
--- /dev/null
+++ b/src/hardware/parport/Makefile.in
@@ -0,0 +1,577 @@
+# Makefile.in generated by automake 1.15 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2014 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/hardware/parport
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
+libparallel_a_AR = $(AR) $(ARFLAGS)
+libparallel_a_LIBADD =
+am_libparallel_a_OBJECTS = parport.$(OBJEXT) directlpt_win32.$(OBJEXT) \
+	directlpt_linux.$(OBJEXT) printer_redir.$(OBJEXT) \
+	printer.$(OBJEXT) printer_charmaps.$(OBJEXT) filelpt.$(OBJEXT)
+libparallel_a_OBJECTS = $(am_libparallel_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+AM_V_CXX = $(am__v_CXX_@AM_V@)
+am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
+am__v_CXX_0 = @echo "  CXX     " $@;
+am__v_CXX_1 = 
+CXXLD = $(CXX)
+CXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \
+	-o $@
+AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
+am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
+am__v_CXXLD_0 = @echo "  CXXLD   " $@;
+am__v_CXXLD_1 = 
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = $(libparallel_a_SOURCES)
+DIST_SOURCES = $(libparallel_a_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/depcomp
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ALSA_CFLAGS = @ALSA_CFLAGS@
+ALSA_LIBS = @ALSA_LIBS@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SDL_CFLAGS = @SDL_CFLAGS@
+SDL_CONFIG = @SDL_CONFIG@
+SDL_LIBS = @SDL_LIBS@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+WINDRES = @WINDRES@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+runstatedir = @runstatedir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AM_CPPFLAGS = -I$(top_srcdir)/include
+noinst_LIBRARIES = libparallel.a
+libparallel_a_SOURCES = parport.cpp \
+			directlpt_win32.cpp directlpt_win32.h \
+			directlpt_linux.cpp directlpt_linux.h \
+			printer_redir.cpp printer_redir.h printer_if.h \
+			printer.cpp printer.h \
+			printer_charmaps.cpp printer_charmaps.h \
+			filelpt.cpp filelpt.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cpp .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu src/hardware/parport/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu src/hardware/parport/Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
+libparallel.a: $(libparallel_a_OBJECTS) $(libparallel_a_DEPENDENCIES) $(EXTRA_libparallel_a_DEPENDENCIES) 
+	$(AM_V_at)-rm -f libparallel.a
+	$(AM_V_AR)$(libparallel_a_AR) libparallel.a $(libparallel_a_OBJECTS) $(libparallel_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libparallel.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directlpt_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directlpt_win32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/filelpt.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parport.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/printer.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/printer_charmaps.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/printer_redir.Po@am__quote@
+
+.cpp.o:
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<
+
+.cpp.obj:
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES cscopelist-am ctags ctags-am distclean \
+	distclean-compile distclean-generic distclean-tags distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
+
+.PRECIOUS: Makefile
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/hardware/parport/directlpt_linux.cpp b/src/hardware/parport/directlpt_linux.cpp
new file mode 100644
index 0000000..0f24baf
--- /dev/null
+++ b/src/hardware/parport/directlpt_linux.cpp
@@ -0,0 +1,164 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include "config.h"
+#include "setup.h"
+
+#if C_DIRECTLPT
+
+/* Linux version */
+#if defined (LINUX)
+
+#include "parport.h"
+#include "directlpt_linux.h"
+#include "callback.h"
+#include <linux/ppdev.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <SDL.h>
+
+CDirectLPT::CDirectLPT (Bitu nr, Bit8u initIrq, CommandLine* cmd)
+                              :CParallel (cmd, nr, initIrq) {
+	InstallationSuccessful = false;
+	interruptflag=true; // interrupt disabled
+
+	std::string str;
+
+	if(!cmd->FindStringBegin("realport:",str,false)) {
+		LOG_MSG("parallel%d: realport parameter missing.",nr+1);
+		return;
+	}
+	porthandle = open(str.c_str(), O_RDWR );
+	if(porthandle == -1) {
+		LOG_MSG("parallel%d: Could not open port %s.",nr+1,str.c_str());
+		if (errno == 2) LOG_MSG ("The specified port does not exist.");
+		else if(errno==EBUSY) LOG_MSG("The specified port is already in use.");
+		else if(errno==EACCES) LOG_MSG("You are not allowed to access this port.");
+		else LOG_MSG("Errno %d occurred.",errno);
+		return;
+	}
+
+	if(ioctl( porthandle, PPCLAIM, NULL ) == -1) {
+		LOG_MSG("parallel%d: failed to claim port.",nr+1);
+		return;
+	}
+	// TODO check return value
+	
+	// go for it
+	ack_polarity=false;
+	initialize();
+
+	InstallationSuccessful = true;
+}
+
+CDirectLPT::~CDirectLPT () {
+	if(porthandle > 0) close(porthandle);
+}
+
+bool CDirectLPT::Putchar(Bit8u val)
+{	
+	//LOG_MSG("putchar: %x",val);
+
+	// check if printer online and not busy
+	// PE and Selected: no printer attached
+	Bit8u sr=Read_SR();
+	//LOG_MSG("SR: %x",sr);
+	if((sr&0x30)==0x30)
+	{
+		LOG_MSG("putchar: no printer");
+		return false;
+	}
+	// error
+	if(sr&0x20)
+	{
+		LOG_MSG("putchar: paper out");
+		return false;
+	}
+	if((sr&0x08)==0)
+	{
+		LOG_MSG("putchar: printer error");
+		return false;
+	}
+
+	Write_PR(val);
+	// busy
+	Bitu timeout = 10000;
+	Bitu time = timeout+SDL_GetTicks();
+
+	while(SDL_GetTicks()<time) {
+		// wait for the printer to get ready
+		for(int i = 0; i < 500; i++) {
+			// do NOT run into callback_idle unless we have to (speeds things up)
+			sr=Read_SR();
+			if(sr&0x80) break;
+		}
+		if(sr&0x80) break;
+		CALLBACK_Idle();
+	}
+	if(SDL_GetTicks()>=time) {
+		LOG_MSG("putchar: busy timeout");
+		return false;
+	}
+	// strobe data out
+	// I hope this creates a sufficient long pulse...
+	// (I/O-Bus at 7.15 MHz will give some delay)
+	
+	for(int i = 0; i < 5; i++) Write_CON(0xd); // strobe on
+	Write_CON(0xc); // strobe off
+
+#if PARALLEL_DEBUG
+	log_par(dbg_putchar,"putchar  0x%2x",val);
+	if(dbg_plainputchar) fprintf(debugfp,"%c",val);
+#endif
+
+	return true;
+}
+Bitu CDirectLPT::Read_PR() {
+	Bitu retval;
+	ioctl(porthandle, PPRDATA, &retval);
+	return retval;
+}
+Bitu CDirectLPT::Read_COM() {
+	Bitu retval;
+	ioctl(porthandle, PPRCONTROL, &retval);
+	return retval;
+}
+Bitu CDirectLPT::Read_SR() {
+	Bitu retval;
+	ioctl(porthandle, PPRSTATUS, &retval);
+	return retval;
+}
+
+void CDirectLPT::Write_PR(Bitu val){
+	ioctl(porthandle, PPWDATA, &val); 
+}
+void CDirectLPT::Write_CON(Bitu val) {
+        val &= 0x1F; // prevent setting old style direction bit
+	ioctl(porthandle, PPWCONTROL, &val); 
+}
+void CDirectLPT::Write_IOSEL(Bitu val) {
+	// switches direction old-style TODO
+	if((val==0xAA)||(val==0x55)) LOG_MSG("TODO implement IBM-style direction switch");
+}
+void CDirectLPT::handleUpperEvent(Bit16u type) {}
+#endif
+#endif
diff --git a/src/hardware/parport/directlpt_linux.h b/src/hardware/parport/directlpt_linux.h
new file mode 100644
index 0000000..2c59fa9
--- /dev/null
+++ b/src/hardware/parport/directlpt_linux.h
@@ -0,0 +1,60 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// include guard
+#ifndef DOSBOX_DIRECTLPT_LINUX_H
+#define DOSBOX_DIRECTLPT_LINUX_H
+
+#include "config.h"
+
+#if C_DIRECTLPT
+#ifdef LINUX
+
+#define DIRECTLPT_AVAILIBLE
+#include "parport.h"
+
+
+class CDirectLPT : public CParallel {
+public:
+	CDirectLPT(Bitu nr, Bit8u initIrq, CommandLine* cmd);
+	
+
+	~CDirectLPT();
+
+	int porthandle;
+	
+	bool interruptflag;
+	bool InstallationSuccessful;	// check after constructing. If
+									// something was wrong, delete it right away.
+	bool ack_polarity;
+
+	Bitu Read_PR();
+	Bitu Read_COM();
+	Bitu Read_SR();
+
+	void Write_PR(Bitu);
+	void Write_CON(Bitu);
+	void Write_IOSEL(Bitu);
+	bool Putchar(Bit8u);
+
+	void handleUpperEvent(Bit16u type);
+};
+
+#endif	// WIN32
+#endif	// C_DIRECTLPT
+#endif	// include guard
diff --git a/src/hardware/parport/directlpt_win32.cpp b/src/hardware/parport/directlpt_win32.cpp
new file mode 100644
index 0000000..1dde4b3
--- /dev/null
+++ b/src/hardware/parport/directlpt_win32.cpp
@@ -0,0 +1,245 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include "dosbox.h"
+
+#if C_DIRECTLPT
+
+/* Windows version */
+#if defined (WIN32)
+
+#include "parport.h"
+#include "../../libs/porttalk/porttalk.h"
+#include "directlpt_win32.h"
+#include "callback.h"
+#include <SDL.h> 
+#include "setup.h"
+
+CDirectLPT::CDirectLPT (Bitu nr, Bit8u initIrq, CommandLine* cmd)
+                              :CParallel (cmd, nr, initIrq) {
+	InstallationSuccessful = false;
+	interruptflag=true; // interrupt disabled
+	realbaseaddress = 0x378;
+
+	std::string str;
+	if(cmd->FindStringBegin("realbase:",str,false)) {
+		if(sscanf(str.c_str(), "%x",&realbaseaddress)!=1) {
+			LOG_MSG("parallel%d: Invalid realbase parameter.",nr);
+			return;
+		} 
+	}
+
+	if(realbaseaddress>=0x10000) {
+		LOG_MSG("Error: Invalid base address.");
+		return;
+	}
+	
+	if(!initPorttalk()) {
+		LOG_MSG("Error: could not open PortTalk driver.");
+		return;
+	}
+	// make sure the user doesn't touch critical I/O-ports
+	if((realbaseaddress<0x100) || (realbaseaddress&0x3) ||		// sanity + mainboard res.
+		((realbaseaddress>=0x1f0)&&(realbaseaddress<=0x1f7)) ||	// prim. HDD controller
+		((realbaseaddress>=0x170)&&(realbaseaddress<=0x177)) ||	// sek. HDD controller
+		((realbaseaddress>=0x3f0)&&(realbaseaddress<=0x3f7)) ||	// floppy + prim. HDD
+		((realbaseaddress>=0x370)&&(realbaseaddress<=0x377))) {	// sek. hdd
+		LOG_MSG("Parallel Port: Invalid base address.");
+		return;
+	}
+	/*	
+	if(realbase!=0x378 && realbase!=0x278 && realbase != 0x3bc)
+	{
+		// TODO PCI ECP ports can be on funny I/O-port-addresses
+		LOG_MSG("Parallel Port: Invalid base address.");
+		return;
+	}*/
+	Bit32u ecpbase = 0;
+	if(cmd->FindStringBegin("ecpbase:",str,false)) {
+		if(sscanf(str.c_str(), "%x",&ecpbase)!=1) {
+			LOG_MSG("parallel%d: Invalid realbase parameter.",nr);
+			return;
+		}
+		isECP=true;
+	} else {
+		// 0x3bc cannot be a ECP port
+		isECP= ((realbaseaddress&0x7)==0);
+		if (isECP) ecpbase = realbaseaddress+0x402;
+	}
+	// add the standard parallel port registers
+	addIOPermission((Bit16u)realbaseaddress);
+	addIOPermission((Bit16u)realbaseaddress+1);
+	addIOPermission((Bit16u)realbaseaddress+2);
+	
+	// if it could be a ECP port: make the extended control register accessible
+	if(isECP)addIOPermission((Bit16u)ecpbase);
+	
+	// bail out if porttalk fails
+	if(!setPermissionList())
+	{
+		LOG_MSG("ERROR SET PERMLIST");
+		return;
+	}
+	if(isECP) {
+		// check if there is a ECP port (try to set bidir)
+		originalECPControlReg = inportb(ecpbase);
+		Bit8u new_bidir = originalECPControlReg&0x1F;
+		new_bidir|=0x20;
+
+		outportb(ecpbase,new_bidir);
+		if(inportb(ecpbase)!=new_bidir) {
+			// this is not a ECP port
+			outportb(ecpbase,originalECPControlReg);
+			isECP=false;
+		}
+	}
+	// check if there is a parallel port at all: the autofeed bit
+	Bit8u controlreg=inportb(realbaseaddress+2);
+	outportb(realbaseaddress+2,controlreg|2);
+	if(!(inportb(realbaseaddress+2)&0x2))
+	{
+		LOG_MSG("No parallel port detected at 0x%x!",realbaseaddress);
+		// cannot remember 1
+		return;
+	}
+	
+	// check 0
+	outportb(realbaseaddress+2,controlreg & ~2);
+	if(inportb(realbaseaddress+2)&0x2)
+	{
+		LOG_MSG("No parallel port detected at 0x%x!",realbaseaddress);
+		// cannot remember 0
+		return;
+	}
+	outportb(realbaseaddress+2,controlreg);
+	
+	if(isECP) LOG_MSG("The port at 0x%x was detected as ECP port.",realbaseaddress);
+	else LOG_MSG("The port at 0x%x is not a ECP port.",realbaseaddress);
+	
+	/*
+	// bidir test
+	outportb(realbase+2,0x20);
+	for(int i = 0; i < 256; i++) {
+		outportb(realbase, i);
+		if(inportb(realbase)!=i) LOG_MSG("NOT %x", i);
+	}
+	*/
+
+	// go for it
+	ack_polarity=false;
+	initialize();
+
+	InstallationSuccessful = true;
+	//LOG_MSG("InstSuccess");
+}
+
+CDirectLPT::~CDirectLPT () {
+	if(InstallationSuccessful && isECP)
+		outportb(realbaseaddress+0x402,originalECPControlReg);
+}
+
+bool CDirectLPT::Putchar(Bit8u val)
+{	
+	//LOG_MSG("putchar: %x",val);
+
+	// check if printer online and not busy
+	// PE and Selected: no printer attached
+	Bit8u sr=Read_SR();
+	//LOG_MSG("SR: %x",sr);
+	if((sr&0x30)==0x30)
+	{
+		LOG_MSG("putchar: no printer");
+		return false;
+	}
+	// error
+	if(sr&0x20)
+	{
+		LOG_MSG("putchar: paper out");
+		return false;
+	}
+	if((sr&0x08)==0)
+	{
+		LOG_MSG("putchar: printer error");
+		return false;
+	}
+
+	Write_PR(val);
+	// busy
+	Bitu timeout = 10000;
+	Bitu time = timeout+SDL_GetTicks();
+
+	while(SDL_GetTicks()<time) {
+		// wait for the printer to get ready
+		for(int i = 0; i < 500; i++) {
+			// do NOT run into callback_idle unless we have to (speeds things up)
+			sr=Read_SR();
+			if(sr&0x80) break;
+		}
+		if(sr&0x80) break;
+		CALLBACK_Idle();
+	}
+	if(SDL_GetTicks()>=time) {
+		LOG_MSG("putchar: busy timeout");
+		return false;
+	}
+	// strobe data out
+	// I hope this creates a sufficient long pulse...
+	// (I/O-Bus at 7.15 MHz will give some delay)
+	
+	for(int i = 0; i < 5; i++) Write_CON(0xd); // strobe on
+	Write_CON(0xc); // strobe off
+
+#if PARALLEL_DEBUG
+	log_par(dbg_putchar,"putchar  0x%2x",val);
+	if(dbg_plainputchar) fprintf(debugfp,"%c",val);
+#endif
+
+	return true;
+}
+Bitu CDirectLPT::Read_PR() {
+	return inportb(realbaseaddress);
+}
+Bitu CDirectLPT::Read_COM() {
+	Bit8u retval=inportb(realbaseaddress+2);
+	if(!interruptflag)// interrupt activated
+	retval&=~0x10;
+	return retval;
+}
+Bitu CDirectLPT::Read_SR() {
+	return inportb(realbaseaddress+1);
+}
+
+void CDirectLPT::Write_PR(Bitu val) {
+	//LOG_MSG("%c,%x",(Bit8u)val,val);
+	outportb(realbaseaddress,val);
+}
+void CDirectLPT::Write_CON(Bitu val) {
+	//do not activate interrupt
+	interruptflag = (val&0x10)!=0;
+	outportb(realbaseaddress+2,val|0x10);
+}
+void CDirectLPT::Write_IOSEL(Bitu val) {
+	outportb(realbaseaddress+1,val);
+}
+
+void CDirectLPT::handleUpperEvent(Bit16u type) {}
+
+
+#endif
+#endif
diff --git a/src/hardware/parport/directlpt_win32.h b/src/hardware/parport/directlpt_win32.h
new file mode 100644
index 0000000..08f68b4
--- /dev/null
+++ b/src/hardware/parport/directlpt_win32.h
@@ -0,0 +1,71 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// include guard
+#ifndef DOSBOX_DIRECTLPT_WIN32_H
+#define DOSBOX_DIRECTLPT_WIN32_H
+
+#include "config.h"
+#include "setup.h"
+
+#if C_DIRECTLPT
+#ifdef WIN32
+
+
+
+#define DIRECTLPT_AVAILIBLE
+#include "parport.h"
+//#include <windows.h>
+
+
+class CDirectLPT : public CParallel {
+public:
+	//HANDLE driverHandle;
+	Bit32u realbaseaddress;
+	Bit8u originalECPControlReg;
+	
+	CDirectLPT(
+			Bitu nr,
+			Bit8u initIrq,
+			CommandLine* cmd
+            );
+	
+
+	~CDirectLPT();
+	
+	bool interruptflag;
+	bool isECP;
+	bool InstallationSuccessful;	// check after constructing. If
+									// something was wrong, delete it right away.
+	bool ack_polarity;
+
+	Bitu Read_PR();
+	Bitu Read_COM();
+	Bitu Read_SR();
+
+	void Write_PR(Bitu);
+	void Write_CON(Bitu);
+	void Write_IOSEL(Bitu);
+	bool Putchar(Bit8u);
+
+	void handleUpperEvent(Bit16u type);
+};
+
+#endif	// WIN32
+#endif	// C_DIRECTLPT
+#endif	// include guard
diff --git a/src/hardware/parport/filelpt.cpp b/src/hardware/parport/filelpt.cpp
new file mode 100644
index 0000000..ad36329
--- /dev/null
+++ b/src/hardware/parport/filelpt.cpp
@@ -0,0 +1,192 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include "dosbox.h"
+
+#include "parport.h"
+#include "filelpt.h"
+#include "callback.h"
+#include "pic.h"
+#include "hardware.h" //OpenCaptureFile
+#include <stdio.h>
+
+#include "printer_charmaps.h"
+
+CFileLPT::CFileLPT (Bitu nr, Bit8u initIrq, CommandLine* cmd)
+                              :CParallel (cmd, nr,initIrq) {
+	InstallationSuccessful = false;
+	fileOpen = false;
+
+	std::string str;
+
+	// add a formfeed when closing?
+	if(cmd->FindStringBegin("addFF",str,false))	addFF = true;
+	else addFF = false;
+
+	// add a formfeed when closing?
+	if(cmd->FindStringBegin("addLF",str,false))	addLF = true;
+	else addLF = false;
+
+	// find the codepage
+	Bitu temp=0;
+	codepage_ptr = NULL;
+	if(cmd->FindStringBegin("cp:",str,false)) {
+		if(sscanf(str.c_str(), "%u",&temp)!=1) {
+			LOG_MSG("parallel%d: Invalid codepage parameter.",nr+1);
+			return;
+		} else {
+			Bitu i = 0;
+			while(charmap[i].codepage!=0) {
+				if(charmap[i].codepage==temp) {
+					codepage_ptr = charmap[i].map;
+					break;
+				}
+				i++;
+			}
+		}
+	}
+	
+	temp=0;
+	if(cmd->FindStringBegin("timeout:",str,false)) {
+		if(sscanf(str.c_str(), "%u",&timeout)!=1) {
+			LOG_MSG("parallel%d: Invalid timeout parameter.",nr+1);
+			return;
+		}
+	} else timeout = 500;
+
+	if(cmd->FindStringBegin("dev:",str,false)) {
+		name = str.c_str();
+		filetype = FILE_DEV;
+	} else if(cmd->FindStringBegin("append:",str,false)) {
+		name = str.c_str();
+		filetype = FILE_APPEND;
+	} else filetype = FILE_CAPTURE;
+
+	InstallationSuccessful = true;
+}
+
+CFileLPT::~CFileLPT () {
+	// close file
+	if(fileOpen)
+		fclose(file);
+	// remove tick handler
+	removeEvent(0);
+}
+
+bool CFileLPT::OpenFile() {
+	switch(filetype) {
+	case FILE_DEV:
+		file = fopen(name.c_str(),"wb");
+		break;
+	case FILE_CAPTURE:
+		file = OpenCaptureFile("Parallel Port Stream",".prt");
+		break;
+	case FILE_APPEND:
+		file = fopen(name.c_str(),"ab");
+		break;
+	}
+
+	if(timeout != 0) setEvent(0, (float)(timeout + 1));
+
+	if(file==NULL) {
+		LOG_MSG("Parallel %d: Failed to open %s",port_nr+1,name.c_str());
+		fileOpen = false;
+		return false;
+	} else {
+		fileOpen = true;
+		return true;
+	}
+}
+
+bool CFileLPT::Putchar(Bit8u val)
+{	
+#if PARALLEL_DEBUG
+	log_par(dbg_putchar,"putchar  0x%2x",val);
+	if(dbg_plainputchar) fprintf(debugfp,"%c",val);
+#endif
+	
+	// write to file (or not)
+	lastUsedTick = PIC_Ticks;
+	if(!fileOpen) if(!OpenFile()) return false;
+
+	if(codepage_ptr!=NULL) {
+		Bit16u extchar = codepage_ptr[val];
+		if(extchar & 0xFF00) fputc((Bitu)(extchar >> 8),file);
+		fputc((Bitu)(extchar & 0xFF),file);
+
+	} else fputc((Bitu)val,file);
+	if(addLF) {
+		if((lastChar == 0x0d) && (val != 0x0a)) {
+			fputc(0xa,file);
+		}
+		lastChar = val;
+	}
+
+	return true;
+}
+Bitu CFileLPT::Read_PR() {
+	return datareg;
+}
+Bitu CFileLPT::Read_COM() {
+	return 0;
+}
+Bitu CFileLPT::Read_SR() {
+	Bit8u status =0x9f;
+	if(!ack) status |= 0x40;
+	ack=false;
+	return status;
+}
+
+void CFileLPT::Write_PR(Bitu val) {
+	datareg = (Bit8u)val;
+}
+void CFileLPT::Write_CON(Bitu val) {
+	// init printer if bit 4 is switched on
+	// ...
+	autofeed = ((val & 0x02)!=0); // autofeed adds 0xa if 0xd is sent
+
+	// data is strobed to the parallel printer on the falling edge of strobe bit
+	if((!(val&0x1)) && (controlreg & 0x1)) {
+		Putchar(datareg);
+		if(autofeed && (datareg==0xd)) Putchar(0xa);
+		ack = true;
+	}
+	controlreg=val;
+}
+void CFileLPT::Write_IOSEL(Bitu val) {
+	// not needed for file printing functionality
+}
+void CFileLPT::handleUpperEvent(Bit16u type) {
+	if(fileOpen) {
+		if(lastUsedTick + timeout < PIC_Ticks) {
+			if(addFF) {
+				fputc(12,file);
+			}
+			fclose(file);
+			lastChar = 0;
+			fileOpen=false;
+			LOG_MSG("Parallel %d: File closed.",port_nr+1);
+		} else {
+			// Port has been touched in the meantime, try again later
+			float new_delay = (float)((timeout + 1) - (PIC_Ticks - lastUsedTick));
+			setEvent(0, new_delay);
+		}
+	}
+}
+
diff --git a/src/hardware/parport/filelpt.h b/src/hardware/parport/filelpt.h
new file mode 100644
index 0000000..fd559ff
--- /dev/null
+++ b/src/hardware/parport/filelpt.h
@@ -0,0 +1,70 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// include guard
+#ifndef DOSBOX_FILELPT_H
+#define DOSBOX_FILELPT_H
+
+#include "dosbox.h"
+#include "parport.h"
+
+typedef enum { FILE_DEV, FILE_CAPTURE, FILE_APPEND } DFTYPE;
+
+class CFileLPT : public CParallel {
+public:
+	CFileLPT (Bitu nr, Bit8u initIrq, CommandLine* cmd);
+
+	~CFileLPT();
+	
+	bool InstallationSuccessful;	// check after constructing. If
+									// something was wrong, delete it right away.
+	
+	bool fileOpen;
+	DFTYPE filetype;			// which mode to operate in (capture,fileappend,device)
+	FILE* file;
+	std::string name;			// name of the thing to open
+	bool addFF;					// add a formfeed character before closing the file/device
+	bool addLF;					// if set, add line feed after carriage return if not used by app
+
+	Bit8u lastChar;				// used to save the previous character to decide wether to add LF
+	const Bit16u* codepage_ptr; // pointer to the translation codepage if not null
+
+	bool OpenFile();
+	
+	bool ack_polarity;
+
+	Bitu Read_PR();
+	Bitu Read_COM();
+	Bitu Read_SR();
+
+	Bit8u datareg;
+	Bit8u controlreg;
+
+	void Write_PR(Bitu);
+	void Write_CON(Bitu);
+	void Write_IOSEL(Bitu);
+	bool Putchar(Bit8u);
+
+	bool autofeed;
+	bool ack;
+	Bitu timeout;
+	Bitu lastUsedTick;
+	virtual void handleUpperEvent(Bit16u type);
+};
+
+#endif	// include guard
diff --git a/src/hardware/parport/parport.cpp b/src/hardware/parport/parport.cpp
new file mode 100644
index 0000000..f18f1fd
--- /dev/null
+++ b/src/hardware/parport/parport.cpp
@@ -0,0 +1,351 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <string.h>
+#include <ctype.h>
+
+#include "dosbox.h"
+
+#include "support.h"
+#include "inout.h"
+#include "pic.h"
+#include "setup.h"
+#include "timer.h"
+#include "bios.h"					// SetLPTPort(..)
+#include "hardware.h"				// OpenCaptureFile
+
+#include "parport.h"
+#include "directlpt_win32.h"
+#include "directlpt_linux.h"
+#include "printer_redir.h"
+#include "filelpt.h"
+#include "dos_inc.h"
+
+bool device_LPT::Read(Bit8u * data,Bit16u * size) {
+	*size=0;
+	LOG(LOG_DOSMISC,LOG_NORMAL)("LPTDEVICE:Read called");
+	return true;
+}
+
+
+bool device_LPT::Write(Bit8u * data,Bit16u * size) {
+	for (Bit16u i=0; i<*size; i++)
+	{
+		if(!pportclass->Putchar(data[i])) return false;
+	}
+	return true;
+}
+
+bool device_LPT::Seek(Bit32u * pos,Bit32u type) {
+	*pos = 0;
+	return true;
+}
+
+bool device_LPT::Close() {
+	return false;
+}
+
+Bit16u device_LPT::GetInformation(void) {
+	return 0x80A0;
+};
+const char* lptname[]={"LPT1","LPT2","LPT3"};
+device_LPT::device_LPT(Bit8u num, class CParallel* pp) {
+	pportclass = pp;
+	SetName(lptname[num]);
+	this->num = num;
+}
+
+device_LPT::~device_LPT() {
+	//LOG_MSG("del");
+}
+
+static void Parallel_EventHandler(Bitu val) {
+	Bitu serclassid=val&0x3;
+	if(parallelPortObjects[serclassid]!=0)
+		parallelPortObjects[serclassid]->handleEvent(val>>2);
+}
+
+void CParallel::setEvent(Bit16u type, float duration) {
+    PIC_AddEvent(Parallel_EventHandler,duration,(type<<2)|port_nr);
+}
+
+void CParallel::removeEvent(Bit16u type) {
+    // TODO
+	PIC_RemoveSpecificEvents(Parallel_EventHandler,(type<<2)|port_nr);
+}
+
+void CParallel::handleEvent(Bit16u type) {
+	handleUpperEvent(type);
+}
+
+static Bitu PARALLEL_Read (Bitu port, Bitu iolen) {
+	for(Bitu i = 0; i < 3; i++) {
+		if(parallel_baseaddr[i]==(port&0xfffc) && (parallelPortObjects[i]!=0)) {
+			Bitu retval=0xff;
+			switch (port & 0x7) {
+				case 0:
+					retval = parallelPortObjects[i]->Read_PR();
+					break;
+				case 1:
+					retval = parallelPortObjects[i]->Read_SR();
+					break;
+				case 2:
+					retval = parallelPortObjects[i]->Read_COM();
+					break;
+			}
+
+#if PARALLEL_DEBUG
+			const char* const dbgtext[]= {"DAT","STA","COM","???"};
+			parallelPortObjects[i]->log_par(parallelPortObjects[i]->dbg_cregs,
+				"read  0x%2x from %s.",retval,dbgtext[port&3]);
+#endif
+			return retval;	
+		}
+	}
+	return 0xff;
+}
+
+static void PARALLEL_Write (Bitu port, Bitu val, Bitu) {
+	for(Bitu i = 0; i < 4; i++) {
+		if(parallel_baseaddr[i]==(port&0xfffc) && parallelPortObjects[i]) {
+#if PARALLEL_DEBUG
+			const char* const dbgtext[]={"DAT","IOS","CON","???"};
+			parallelPortObjects[i]->log_par(parallelPortObjects[i]->dbg_cregs,
+				"write 0x%2x to %s.",val,dbgtext[port&3]);
+			if(parallelPortObjects[i]->dbg_plaindr &&!(port & 0x3)) {
+				fprintf(parallelPortObjects[i]->debugfp,"%c",val);
+			}
+#endif
+			switch (port & 0x3) {
+				case 0:
+					parallelPortObjects[i]->Write_PR (val);
+					return;
+				case 1:
+					parallelPortObjects[i]->Write_IOSEL (val);
+					return;
+				case 2:
+					parallelPortObjects[i]->Write_CON (val);
+					return;
+			}
+		}
+	}
+}
+
+//The Functions
+
+#if PARALLEL_DEBUG
+#include <stdarg.h>
+void CParallel::log_par(bool active, char const* format,...) {
+	if(active) {
+		// copied from DEBUG_SHOWMSG
+		char buf[512];
+		buf[0]=0;
+		sprintf(buf,"%12.3f ",PIC_FullIndex());
+		va_list msg;
+		va_start(msg,format);
+		vsprintf(buf+strlen(buf),format,msg);
+		va_end(msg);
+		// Add newline if not present
+		Bitu len=strlen(buf);
+		if(buf[len-1]!='\n') strcat(buf,"\r\n");
+		fputs(buf,debugfp);
+	}
+}
+#endif
+
+// Initialisation
+CParallel::CParallel(CommandLine* cmd, Bitu portnr, Bit8u initirq) {
+	base = parallel_baseaddr[portnr];
+	irq = initirq;
+	port_nr = portnr;
+
+#if PARALLEL_DEBUG
+	dbg_data	= cmd->FindExist("dbgdata", false);
+	dbg_putchar = cmd->FindExist("dbgput", false);
+	dbg_cregs	= cmd->FindExist("dbgregs", false);
+	dbg_plainputchar = cmd->FindExist("dbgputplain", false);
+	dbg_plaindr = cmd->FindExist("dbgdataplain", false);
+	
+	if(cmd->FindExist("dbgall", false)) {
+		dbg_data= 
+		dbg_putchar=
+		dbg_cregs=true;
+		dbg_plainputchar=dbg_plaindr=false;
+	}
+
+	if(dbg_data||dbg_putchar||dbg_cregs||dbg_plainputchar||dbg_plaindr)
+		debugfp=OpenCaptureFile("parlog",".parlog.txt");
+	else debugfp=0;
+
+	if(debugfp == 0) {
+		dbg_data= 
+		dbg_putchar=dbg_plainputchar=
+		dbg_cregs=false;
+	} else {
+		std::string cleft;
+		cmd->GetStringRemain(cleft);
+
+		log_par(true,"Parallel%d: BASE %xh, initstring \"%s\"\r\n\r\n",
+			portnr+1,base,cleft.c_str());
+	}
+#endif
+	LOG_MSG("Parallel%d: BASE %xh",portnr+1,base);
+
+	for (Bitu i = 0; i < 3; i++) {
+		WriteHandler[i].Install (i + base, PARALLEL_Write, IO_MB);
+		ReadHandler[i].Install (i + base, PARALLEL_Read, IO_MB);
+	}
+	BIOS_SetLPTPort(portnr,base);
+	mydosdevice=new device_LPT(portnr, this);
+	DOS_AddDevice(mydosdevice);
+};
+
+CParallel::~CParallel(void) {
+	BIOS_SetLPTPort(port_nr,0);
+	if(mydosdevice) DOS_DelDevice(mydosdevice);
+};
+
+Bit8u CParallel::getPrinterStatus()
+{
+	/*	7      not busy
+		6      acknowledge
+		5      out of paper
+		4      selected
+		3      I/O error
+		2-1    unused
+		0      timeout  */
+	Bit8u statusreg=Read_SR();
+
+	//LOG_MSG("get printer status: %x",statusreg);
+	statusreg^=0x48;
+	return statusreg&~0x7;
+}
+
+#include "callback.h"
+
+void RunIdleTime(Bitu milliseconds)
+{
+	Bitu time=SDL_GetTicks()+milliseconds;
+	while(SDL_GetTicks()<time)
+		CALLBACK_Idle();
+}
+
+void CParallel::initialize()
+{
+	Write_IOSEL(0x55); // output mode
+	Write_CON(0x08); // init low
+	Write_PR(0);
+	RunIdleTime(10);
+	Write_CON(0x0c); // init high
+	RunIdleTime(500);
+	//LOG_MSG("printer init");
+}
+
+
+
+CParallel* parallelPortObjects[3];
+class PARPORTS:public Module_base {
+public:
+	
+	PARPORTS (Section * configuration):Module_base (configuration) {
+
+#if C_PRINTER
+		bool printer_used = false;
+#endif
+
+		// default ports & interrupts
+		Bit8u defaultirq[] = { 7, 5, 12};
+		Section_prop *section = static_cast <Section_prop*>(configuration);
+		
+		char pname[]="parallelx";
+		// iterate through all 3 lpt ports
+		for (Bitu i = 0; i < 3; i++) {
+			pname[8] = '1' + i;
+			CommandLine cmd(0,section->Get_string(pname));
+
+			std::string str;
+			cmd.FindCommand(1,str);
+#ifdef C_DIRECTLPT			
+			if(str=="reallpt") {
+				CDirectLPT* cdlpt= new CDirectLPT(i, defaultirq[i],&cmd);
+				if(cdlpt->InstallationSuccessful)
+					parallelPortObjects[i]=cdlpt;
+				else {
+					delete cdlpt;
+					parallelPortObjects[i]=0;
+				}
+			}
+			else
+#endif
+			if(!str.compare("file")) {
+				CFileLPT* cflpt= new CFileLPT(i, defaultirq[i], &cmd);
+				if(cflpt->InstallationSuccessful)
+					parallelPortObjects[i]=cflpt;
+				else {
+					delete cflpt;
+					parallelPortObjects[i]=0;
+				}
+			}
+			else 
+#if C_PRINTER
+			if(str=="printer") {
+				if(printer_used) {
+					
+				}; // only one parallel port with printer
+				CPrinterRedir* cprd = new CPrinterRedir(i,defaultirq[i],&cmd);
+				if(cprd->InstallationSuccessful) {
+					parallelPortObjects[i]=cprd;
+					printer_used=true;
+				} else {
+					LOG_MSG("Error: printer is not enabled.");
+					delete cprd;
+					parallelPortObjects[i]=0;
+				}
+			} else
+#endif				
+			if(str=="disabled") {
+				parallelPortObjects[i] = 0;
+			} else {
+				LOG_MSG ("Invalid type for LPT%d.", i + 1);
+				parallelPortObjects[i] = 0;
+			}
+		} // for lpt 1-3
+	}
+
+	~PARPORTS () {
+		for (Bitu i = 0; i < 3; i++)
+			if (parallelPortObjects[i]) {
+				delete parallelPortObjects[i];
+				parallelPortObjects[i] = 0;
+			}
+	}
+};
+
+static PARPORTS *testParallelPortsBaseclass;
+
+void PARALLEL_Destroy (Section * sec) {
+	delete testParallelPortsBaseclass;
+	testParallelPortsBaseclass = NULL;
+}
+
+void PARALLEL_Init (Section * sec) {
+	// should never happen
+	if (testParallelPortsBaseclass) delete testParallelPortsBaseclass;
+	testParallelPortsBaseclass = new PARPORTS (sec);
+	sec->AddDestroyFunction (&PARALLEL_Destroy, true);
+}
diff --git a/src/hardware/parport/printer.cpp b/src/hardware/parport/printer.cpp
new file mode 100644
index 0000000..ad80563
--- /dev/null
+++ b/src/hardware/parport/printer.cpp
@@ -0,0 +1,2127 @@
+/*
+ *  Copyright (C) 2002-2004  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "printer.h"
+
+#if C_PRINTER
+
+#include <math.h>
+#include "setup.h"
+#include "mapper.h"
+#include "printer_if.h"
+#include "support.h"
+#include "printer_charmaps.h"
+
+#include "pic.h" // for timeout
+
+extern void GFX_CaptureMouse(void);
+extern bool mouselocked;
+
+static CPrinter* defaultPrinter = NULL;
+
+#define PARAM16(I) (params[I+1]*256+params[I])
+#define PIXX ((Bitu)floor(curX*dpi+0.5))
+#define PIXY ((Bitu)floor(curY*dpi+0.5))
+
+static Bit16u confdpi, confwidth, confheight;
+static Bitu printer_timout;
+static bool timeout_dirty;
+static const char* document_path;
+//static const char* font_path;
+static char confoutputDevice[50];
+static bool confmultipageOutput;
+
+void CPrinter::FillPalette(Bit8u redmax, Bit8u greenmax, Bit8u bluemax, Bit8u colorID, SDL_Palette* pal)
+{
+	float red=redmax/30.9;
+	float green=greenmax/30.9;
+	float blue=bluemax/30.9;
+
+	Bit8u colormask=colorID<<=5;
+
+	for(int i = 0; i < 32;i++) {
+		pal->colors[i+colormask].r=255-(red*(float)i);
+		pal->colors[i+colormask].g=255-(green*(float)i);
+		pal->colors[i+colormask].b=255-(blue*(float)i);
+	}
+}
+
+CPrinter::CPrinter(Bit16u dpi, Bit16u width, Bit16u height, char* output, bool multipageOutput) 
+{
+	if (FT_Init_FreeType(&FTlib))
+	{
+		LOG(LOG_MISC,LOG_ERROR)("PRINTER: Unable to init Freetype2. Printing disabled");
+		page = NULL;
+	}
+	else
+	{
+		this->dpi = dpi;
+		this->output = output;
+		this->multipageOutput = multipageOutput;
+
+		defaultPageWidth = (Real64)width/(Real64)10;
+		defaultPageHeight = (Real64)height/(Real64)10;
+
+		// Create page
+		page = SDL_CreateRGBSurface(
+						SDL_SWSURFACE, 
+						(Bitu)(defaultPageWidth*dpi), 
+						(Bitu)(defaultPageHeight*dpi), 
+						8, 
+						0, 
+						0, 
+						0, 
+						0);
+
+		// Set a grey palette
+		SDL_Palette* palette = page->format->palette;
+		
+		for (Bitu i=0; i<32; i++)
+		{
+			palette->colors[i].r =255;
+			palette->colors[i].g =255;
+			palette->colors[i].b =255;
+		}
+		// 0 = all white needed for logic 000
+		FillPalette(  0,   0,   0, 1, palette);
+		// 1 = magenta* 001
+		FillPalette(  0, 255,   0, 1, palette);
+		// 2 = cyan*    010
+		FillPalette(255,   0,   0, 2, palette);
+		// 3 = "violet" 011
+		FillPalette(255, 255,   0, 3, palette);
+		// 4 = yellow*  100
+		FillPalette(  0,   0, 255, 4, palette);
+		// 5 = red      101
+		FillPalette(  0, 255, 255, 5, palette);
+		// 6 = green    110
+		FillPalette(255,   0, 255, 6, palette);
+		// 7 = black    111
+		FillPalette(255, 255, 255, 7, palette);
+
+		// yyyxxxxx bit pattern: yyy=color xxxxx = intensity: 31=max
+		// Printing colors on top of each other ORs them and gets the
+		// correct resulting color.
+		// i.e. magenta on blank page yyy=001
+		// then yellow on magenta 001 | 100 = 101 = red
+		
+		color=COLOR_BLACK;
+		
+		curFont = NULL;
+		charRead = false;
+		autoFeed = false;
+		outputHandle = NULL;
+
+		resetPrinter();
+
+		if (strcasecmp(output, "printer") == 0)
+		{
+#if defined (WIN32)
+			// Show Print dialog to obtain a printer device context
+
+			PRINTDLG pd;
+			pd.lStructSize = sizeof(PRINTDLG); 
+			pd.hDevMode = (HANDLE) NULL; 
+			pd.hDevNames = (HANDLE) NULL; 
+			pd.Flags = PD_RETURNDC; 
+			pd.hwndOwner = NULL; 
+			pd.hDC = (HDC) NULL; 
+			pd.nFromPage = 1; 
+			pd.nToPage = 1; 
+			pd.nMinPage = 0; 
+			pd.nMaxPage = 0; 
+			pd.nCopies = 1; 
+			pd.hInstance = NULL; 
+			pd.lCustData = 0L; 
+			pd.lpfnPrintHook = (LPPRINTHOOKPROC) NULL; 
+			pd.lpfnSetupHook = (LPSETUPHOOKPROC) NULL; 
+			pd.lpPrintTemplateName = (LPSTR) NULL; 
+			pd.lpSetupTemplateName = (LPSTR)  NULL; 
+			pd.hPrintTemplate = (HANDLE) NULL; 
+			pd.hSetupTemplate = (HANDLE) NULL; 
+			PrintDlg(&pd);
+			// TODO: what if user presses cancel?
+			printerDC = pd.hDC;
+#endif
+		}
+		LOG(LOG_MISC,LOG_NORMAL)("PRINTER: Enabled");
+	}
+};
+
+void CPrinter::resetPrinterHard()
+{
+	charRead = false;
+	resetPrinter();
+}
+
+void CPrinter::resetPrinter()
+{
+		color=COLOR_BLACK;
+		curX = curY = 0.0;
+		ESCSeen = false;
+		FSSeen = false;
+		ESCCmd = 0;
+		numParam = neededParam = 0;
+		topMargin = 0.0;
+		leftMargin = 0.0;
+		rightMargin = pageWidth = defaultPageWidth;
+		bottomMargin = pageHeight = defaultPageHeight;
+		lineSpacing = (Real64)1/6;
+		cpi = 10.0;
+		curCharTable = 1;
+		style = 0;
+		extraIntraSpace = 0.0;
+		printUpperContr = true;
+		bitGraph.remBytes = 0;
+		densk = 0;
+		densl = 1;
+		densy = 2;
+		densz = 3;
+		charTables[0] = 0; // Italics
+		charTables[1] = charTables[2] = charTables[3] = 437;
+		definedUnit = -1;
+		multipoint = false;
+		multiPointSize = 0.0;
+		multicpi = 0.0;
+		hmi = -1.0;
+		msb = 255;
+		numPrintAsChar = 0;
+		LQtypeFace = roman;
+
+		selectCodepage(charTables[curCharTable]);
+
+		updateFont();
+
+		newPage(false,true);
+
+		// Default tabs => Each eight characters
+		for (Bitu i=0;i<32;i++)
+			horiztabs[i] = i*8*(1/(Real64)cpi);
+		numHorizTabs = 32;
+
+		numVertTabs = 255;
+}
+
+
+CPrinter::~CPrinter(void)
+{
+	finishMultipage();
+	if (page != NULL)
+	{
+		SDL_FreeSurface(page);
+		page = NULL;
+		FT_Done_FreeType(FTlib);
+	}
+#if defined (WIN32)
+	DeleteDC(printerDC);
+#endif
+};
+
+void CPrinter::selectCodepage(Bit16u cp)
+{
+	const Bit16u* mapToUse = NULL;
+
+	Bitu i = 0;
+	while(charmap[i].codepage!=0) {
+		if(charmap[i].codepage==cp) {
+			mapToUse = charmap[i].map;
+			break;
+		}
+		i++;
+	}
+	if (mapToUse == NULL) {
+		LOG(LOG_MISC,LOG_WARN)("Unsupported codepage %i. Using CP437 instead.", cp);
+		selectCodepage(437);
+		return;
+	}/*
+	switch(cp)
+	{
+	case 0: // Italics, use cp437
+	case 437:
+		mapToUse = (Bit16u*)&cp437Map;
+		break;
+	case 737:
+		mapToUse = (Bit16u*)&cp737Map;
+		break;
+	case 775:
+		mapToUse = (Bit16u*)&cp775Map;
+		break;
+	case 850:
+		mapToUse = (Bit16u*)&cp850Map;
+		break;
+	case 852:
+		mapToUse = (Bit16u*)&cp852Map;
+		break;
+	case 855:
+		mapToUse = (Bit16u*)&cp855Map;
+		break;
+	case 857:
+		mapToUse = (Bit16u*)&cp857Map;
+		break;
+	case 860:
+		mapToUse = (Bit16u*)&cp860Map;
+		break;
+	case 861:
+		mapToUse = (Bit16u*)&cp861Map;
+		break;
+	case 863:
+		mapToUse = (Bit16u*)&cp863Map;
+		break;
+	case 864:
+		mapToUse = (Bit16u*)&cp864Map;
+		break;
+	case 865:
+		mapToUse = (Bit16u*)&cp865Map;
+		break;
+	case 866:
+		mapToUse = (Bit16u*)&cp866Map;
+		break;
+	default:
+		LOG(LOG_MISC,LOG_WARN)("Unsupported codepage %i. Using CP437 instead.", cp);
+		mapToUse = (Bit16u*)&cp437Map;
+	}*/
+
+	for (int i=0; i<256; i++)
+		curMap[i] = mapToUse[i];
+}
+
+void CPrinter::updateFont()
+{
+	//	char buffer[1000]; 
+
+	if (curFont != NULL)
+		FT_Done_Face(curFont);
+
+	const char* fontName;
+
+	switch (LQtypeFace)
+	{
+	case roman:
+		fontName = "roman.ttf";
+		break;
+	case sansserif:
+		fontName = "sansserif.ttf";
+		break;
+	case courier:
+		fontName = "courier.ttf";
+		break;
+	case script:
+		fontName = "script.ttf";
+		break;
+	case ocra:
+	case ocrb:
+		fontName = "ocra.ttf";
+		break;
+	default:
+		fontName = "roman.ttf";
+	}
+	
+	if (FT_New_Face(FTlib, fontName, 0, &curFont))
+	{
+		//LOG(LOG_MISC,LOG_ERROR)("Unable to load font %s", fontName);
+		LOG_MSG("Unable to load font %s", fontName);
+		curFont = NULL;
+	}
+
+	Real64 horizPoints = 10.5;
+	Real64 vertPoints = 10.5;
+
+	if (!multipoint) {
+		actcpi = cpi;
+		/*
+		switch(style & (STYLE_CONDENSED|STYLE_PROP)) {
+			case STYLE_CONDENSED: // only condensed
+				if (cpi == 10.0) {
+					actcpi = 17.14;
+					horizPoints *= 10.0/17.14;
+				} else if(cpi == 12.0) {
+					actcpi = 20.0;
+					horizPoints *= 10.0/20.0;
+					vertPoints *= 10.0/12.0;
+				} else {
+					// ignored
+				}
+				break;
+			case STYLE_PROP|STYLE_CONDENSED:
+				horizPoints /= 2.0;
+				break;
+			case 0: // neither
+			case STYLE_PROP: // only proportional
+				horizPoints *= 10.0/cpi;
+				vertPoints *= 10.0/cpi;
+				break;
+		}
+	*/
+		if (!(style & STYLE_CONDENSED)) {
+			horizPoints *= 10.0/cpi;
+			vertPoints *= 10.0/cpi;
+		}
+
+		if (!(style & STYLE_PROP)) {
+			if ((cpi == 10.0) && (style & STYLE_CONDENSED)) {
+				actcpi = 17.14;
+				horizPoints *= 10.0/17.14;
+			}
+			if ((cpi == 12.0) && (style & STYLE_CONDENSED)) {
+				actcpi = 20.0;
+				horizPoints *= 10.0/20.0;
+				vertPoints *= 10.0/12.0;
+			}	
+		} else if (style & STYLE_CONDENSED) horizPoints /= 2.0;
+
+
+		if ((style & STYLE_DOUBLEWIDTH) || (style & STYLE_DOUBLEWIDTHONELINE)) {
+			actcpi /= 2.0;
+			horizPoints *= 2.0;
+		}
+
+		if (style & STYLE_DOUBLEHEIGHT)	vertPoints *= 2.0;
+	} else { // multipoint true
+		actcpi = multicpi;
+		horizPoints = vertPoints = multiPointSize;
+	}
+
+	if ((style & STYLE_SUPERSCRIPT) || (style & STYLE_SUBSCRIPT)) {
+		horizPoints *= 2.0/3.0;
+		vertPoints *= 2.0/3.0;
+		actcpi /= 2.0/3.0;
+	}
+
+	FT_Set_Char_Size(curFont, (Bit16u)horizPoints*64, (Bit16u)vertPoints*64, dpi, dpi);
+	
+	if (style & STYLE_ITALICS || charTables[curCharTable] == 0)
+	{
+		FT_Matrix  matrix;
+		matrix.xx = 0x10000L;
+		matrix.xy = (FT_Fixed)(0.20 * 0x10000L);
+		matrix.yx = 0;
+		matrix.yy = 0x10000L;
+		FT_Set_Transform(curFont, &matrix, 0);
+	}
+}
+
+bool CPrinter::processCommandChar(Bit8u ch)
+{
+	if (ESCSeen || FSSeen)
+	{
+		ESCCmd = ch;
+		if(FSSeen) ESCCmd |= 0x800;
+		ESCSeen = FSSeen = false;
+		numParam = 0;
+
+		switch (ESCCmd) {
+		case 0x02: // Undocumented
+		case 0x0a: // Reverse line feed											(ESC LF)
+		case 0x0c: // Return to top of current page								(ESC FF)
+		case 0x0e: // Select double-width printing (one line)					(ESC SO)		
+		case 0x0f: // Select condensed printing									(ESC SI)
+		case 0x23: // Cancel MSB control										(ESC #)
+		case 0x30: // Select 1/8-inch line spacing								(ESC 0)
+		case 0x31: // Select 7/60-inch line spacing								(ESC 1)
+		case 0x32: // Select 1/6-inch line spacing								(ESC 2)
+		case 0x34: // Select italic font										(ESC 4)
+		case 0x35: // Cancel italic font										(ESC 5)
+		case 0x36: // Enable printing of upper control codes					(ESC 6)
+		case 0x37: // Enable upper control codes								(ESC 7)
+		case 0x38: // Disable paper-out detector								(ESC 8)
+		case 0x39: // Enable paper-out detector									(ESC 9)
+		case 0x3c: // Unidirectional mode (one line)							(ESC <)
+		case 0x3d: // Set MSB to 0												(ESC =)
+		case 0x3e: // Set MSB to 1												(ESC >)
+		case 0x40: // Initialize printer										(ESC @)
+		case 0x45: // Select bold font											(ESC E)
+		case 0x46: // Cancel bold font											(ESC F)
+		case 0x47: // Select double-strike printing								(ESC G)
+		case 0x48: // Cancel double-strike printing								(ESC H)
+		case 0x4d: // Select 10.5-point, 12-cpi									(ESC M)
+		case 0x4f: // Cancel bottom margin [conflict]							(ESC O)
+		case 0x50: // Select 10.5-point, 10-cpi									(ESC P)
+		case 0x54: // Cancel superscript/subscript printing						(ESC T)
+		case 0x5e: // Enable printing of all character codes on next character	(ESC ^)
+		case 0x67: // Select 10.5-point, 15-cpi									(ESC g)
+
+		case 0x834: // Select italic font								(FS 4)	(= ESC 4)
+		case 0x835: // Cancel italic font								(FS 5)	(= ESC 5)
+		case 0x846: // Select forward feed mode							(FS F)
+		case 0x852: // Select reverse feed mode							(FS R)
+			neededParam = 0;
+			break;
+		case 0x19: // Control paper loading/ejecting							(ESC EM)
+		case 0x20: // Set intercharacter space									(ESC SP)
+		case 0x21: // Master select												(ESC !)
+		case 0x2b: // Set n/360-inch line spacing								(ESC +)
+		case 0x2d: // Turn underline on/off										(ESC -)
+		case 0x2f: // Select vertical tab channel								(ESC /)
+		case 0x33: // Set n/180-inch line spacing								(ESC 3)
+		case 0x41: // Set n/60-inch line spacing								(ESC A)
+		case 0x43: // Set page length in lines									(ESC C)
+		case 0x49: // Select character type and print pitch						(ESC I)
+		case 0x4a: // Advance print position vertically							(ESC J)
+		case 0x4e: // Set bottom margin											(ESC N)
+		case 0x51: // Set right margin											(ESC Q)
+		case 0x52: // Select an international character set						(ESC R)
+		case 0x53: // Select superscript/subscript printing						(ESC S)
+		case 0x55: // Turn unidirectional mode on/off							(ESC U)
+		//case 0x56: // Repeat data												(ESC V)
+		case 0x57: // Turn double-width printing on/off							(ESC W)
+		case 0x61: // Select justification										(ESC a)
+		case 0x66: // Absolute horizontal tab in columns [conflict]				(ESC f)
+		case 0x68: // Select double or quadruple size							(ESC h)
+		case 0x69: // Immediate print											(ESC i)
+		case 0x6a: // Reverse paper feed										(ESC j)
+		case 0x6b: // Select typeface											(ESC k)
+		case 0x6c: // Set left margin											(ESC 1)
+		case 0x70: // Turn proportional mode on/off								(ESC p)
+		case 0x72: // Select printing color										(ESC r)
+		case 0x73: // Low-speed mode on/off										(ESC s)
+		case 0x74: // Select character table									(ESC t)
+		case 0x77: // Turn double-height printing on/off						(ESC w)
+		case 0x78: // Select LQ or draft										(ESC x)
+		case 0x7e: // Select/Deselect slash zero								(ESC ~)
+
+		case 0x832: // Select 1/6-inch line spacing						(FS 2)	(= ESC 2)
+		case 0x833: // Set n/360-inch line spacing						(FS 3)	(= ESC +)
+		case 0x841: // Set n/60-inch line spacing						(FS A)	(= ESC A)
+		case 0x843:	// Select LQ type style								(FS C)	(= ESC k)
+		case 0x845: // Select character width							(FS E)
+		case 0x849: // Select character table							(FS I)	(= ESC t)
+		case 0x853: // Select High Speed/High Density elite pitch		(FS S)
+		case 0x856: // Turn double-height printing on/off				(FS V)	(= ESC w)
+			neededParam = 1;
+			break;
+		case 0x24: // Set absolute horizontal print position					(ESC $)
+		case 0x3f: // Reassign bit-image mode									(ESC ?)
+		case 0x4b: // Select 60-dpi graphics									(ESC K)
+		case 0x4c: // Select 120-dpi graphics									(ESC L)
+		case 0x59: // Select 120-dpi, double-speed graphics						(ESC Y)
+		case 0x5a: // Select 240-dpi graphics									(ESC Z)
+		case 0x5c: // Set relative horizontal print position					(ESC \)
+		case 0x63: // Set horizontal motion index (HMI)	[conflict]				(ESC c)
+		case 0x65: // Set vertical tab stops every n lines						(ESC e)
+		case 0x85a: // Print 24-bit hex-density graphics						(FS Z)
+			neededParam = 2;
+			break;
+		case 0x2a: // Select bit image											(ESC *)
+		case 0x58: // Select font by pitch and point [conflict]					(ESC X)
+			neededParam = 3;
+			break;
+		case 0x5b: // Select character height, width, line spacing
+			neededParam = 7;
+			break;
+		case 0x62: // Set vertical tabs in VFU channels							(ESC b) 
+		case 0x42: // Set vertical tabs											(ESC B)
+			numVertTabs = 0;
+			return true;
+		case 0x44: // Set horizontal tabs										(ESC D)
+			numHorizTabs = 0;
+			return true;
+		case 0x25: // Select user-defined set									(ESC %)
+		case 0x26: // Define user-defined characters							(ESC &)
+		case 0x3a: // Copy ROM to RAM											(ESC :)
+			LOG(LOG_MISC,LOG_ERROR)("User-defined characters not supported!");
+			return true;
+		case 0x28: // Two bytes sequence
+			return true;
+		default:
+			LOG_MSG("PRINTER: Unknown command %s (%02Xh) %c , unable to skip parameters.",
+				(ESCCmd & 0x800)?"FS":"ESC",ESCCmd, ESCCmd);
+			
+			neededParam = 0;
+			ESCCmd = 0;
+			return true;
+		}
+
+		if (neededParam > 0)
+			return true;
+	}
+
+	// Two bytes sequence
+	if (ESCCmd == '(')
+	{
+		ESCCmd = 0x200 + ch;
+
+		switch (ESCCmd)
+		{
+		case 0x242: // Bar code setup and print (ESC (B)
+		case 0x25e: // Print data as characters (ESC (^)
+			neededParam = 2;
+			break;
+		case 0x255: // Set unit (ESC (U)
+			neededParam = 3;
+			break;
+		case 0x243: // Set page length in defined unit (ESC (C)
+		case 0x256: // Set absolute vertical print position (ESC (V)
+		case 0x276: // Set relative vertical print position (ESC (v)
+			neededParam = 4;
+			break;
+		case 0x274: // Assign character table (ESC (t)
+		case 0x22d: // Select line/score (ESC (-)
+			neededParam = 5;
+			break;
+		case 0x263: // Set page format (ESC (c)
+			neededParam = 6;
+			break;
+		default:
+			// ESC ( commands are always followed by a "number of parameters" word parameter
+			//LOG(LOG_MISC,LOG_ERROR)
+				LOG_MSG("PRINTER: Skipping unsupported command ESC ( %c (%02X).", ESCCmd, ESCCmd);
+			neededParam = 2;
+			ESCCmd = 0x101;
+			return true;
+		}
+
+		if (neededParam > 0)
+			return true;
+	}
+
+	// Ignore VFU channel setting
+	if (ESCCmd == 0x62) {
+		ESCCmd = 0x42;
+		return true;
+	}
+
+	// Collect vertical tabs
+	if (ESCCmd == 0x42) {
+		if (ch == 0 || (numVertTabs>0 && verttabs[numVertTabs-1] > (Real64)ch*lineSpacing)) // Done
+			ESCCmd = 0;
+		else
+			if (numVertTabs < 16)
+				verttabs[numVertTabs++] = (Real64)ch*lineSpacing;
+	}
+
+	// Collect horizontal tabs
+	if (ESCCmd == 0x44) 
+	{
+		if (ch == 0 || (numHorizTabs>0 && horiztabs[numHorizTabs-1] > (Real64)ch*(1/(Real64)cpi))) // Done
+			ESCCmd = 0;
+		else
+			if (numHorizTabs < 32)
+				horiztabs[numHorizTabs++] = (Real64)ch*(1/(Real64)cpi);
+	}
+
+	if (numParam < neededParam)
+	{
+		params[numParam++] = ch;
+
+		if (numParam < neededParam)
+			return true;
+	}
+
+	if (ESCCmd != 0)
+	{
+		switch (ESCCmd)
+		{
+		case 0x02: // Undocumented
+			// Ignore
+			break;
+		case 0x0e: // Select double-width printing (one line) (ESC SO)		
+			if (!multipoint)
+			{
+				hmi = -1;
+				style |= STYLE_DOUBLEWIDTHONELINE;
+				updateFont();
+			}
+			break;
+		case 0x0f: // Select condensed printing (ESC SI)
+			if (!multipoint && (cpi!=15.0)) {
+				hmi = -1;
+				style |= STYLE_CONDENSED;
+				updateFont();
+			}
+			break;
+		case 0x19: // Control paper loading/ejecting (ESC EM)
+			// We are not really loading paper, so most commands can be ignored
+			if (params[0] == 'R')
+				newPage(true,false); // TODO resetx?
+			break;
+		case 0x20: // Set intercharacter space (ESC SP)
+			if (!multipoint)
+			{
+				extraIntraSpace = (Real64)params[0] / (printQuality==QUALITY_DRAFT?120:180);
+				hmi = -1;
+				updateFont();
+			}
+			break;
+		case 0x21: // Master select (ESC !)
+			cpi = params[0] & 0x01 ? 12:10;
+
+			// Reset first seven bits
+			style &= 0xFF80;
+			if (params[0] & 0x02)
+				style |= STYLE_PROP;
+			if (params[0] & 0x04)
+ 				style |= STYLE_CONDENSED;
+			if (params[0] & 0x08)
+ 				style |= STYLE_BOLD;
+			if (params[0] & 0x10)
+ 				style |= STYLE_DOUBLESTRIKE;
+			if (params[0] & 0x20)
+ 				style |= STYLE_DOUBLEWIDTH;
+			if (params[0] & 0x40)
+ 				style |= STYLE_ITALICS;
+			if (params[0] & 0x80)
+			{
+				score = SCORE_SINGLE;
+ 				style |= STYLE_UNDERLINE;
+			}
+
+			hmi = -1;
+			multipoint = false;
+			updateFont();
+			break;
+		case 0x23: // Cancel MSB control (ESC #)
+			msb = 255;
+			break;
+		case 0x24: // Set absolute horizontal print position (ESC $)
+			{
+				Real64 unitSize = definedUnit;
+				if (unitSize < 0)
+					unitSize = (Real64)60.0;
+
+				Real64 newX = leftMargin + ((Real64)PARAM16(0)/unitSize);
+				if (newX <= rightMargin)
+					curX = newX;
+			}
+			break;
+		case 0x85a: // Print 24-bit hex-density graphics (FS Z)
+			setupBitImage(40, PARAM16(0));
+			break;
+		case 0x2a: // Select bit image (ESC *)
+			setupBitImage(params[0], PARAM16(1));
+			break;
+		case 0x2b: // Set n/360-inch line spacing (ESC +)
+		case 0x833: // Set n/360-inch line spacing (FS 3)
+			lineSpacing = (Real64)params[0]/360;
+			break;
+		case 0x2d: // Turn underline on/off (ESC -)
+			if (params[0] == 0 || params[0] == 48)
+				style &= ~STYLE_UNDERLINE;
+			if (params[0] == 1 || params[0] == 49)
+			{
+				style |= STYLE_UNDERLINE;
+				score = SCORE_SINGLE;
+			}
+			updateFont();
+			break;
+		case 0x2f: // Select vertical tab channel (ESC /)
+			// Ignore
+			break;
+		case 0x30: // Select 1/8-inch line spacing (ESC 0)
+			lineSpacing = (Real64)1/8;
+			break;
+		case 0x32: // Select 1/6-inch line spacing (ESC 2)
+			lineSpacing = (Real64)1/6;
+			break;
+		case 0x33: // Set n/180-inch line spacing (ESC 3)
+			lineSpacing = (Real64)params[0]/180;
+			break;
+		case 0x34: // Select italic font (ESC 4)
+			style |= STYLE_ITALICS;
+			updateFont();
+			break;
+		case 0x35: // Cancel italic font (ESC 5)
+			style &= ~STYLE_ITALICS;
+			updateFont();
+			break;
+		case 0x36: // Enable printing of upper control codes (ESC 6)
+			printUpperContr = true;
+			break;
+		case 0x37: // Enable upper control codes (ESC 7)
+			printUpperContr = false;
+			break;
+		case 0x3c: // Unidirectional mode (one line) (ESC <)
+			// We don't have a print head, so just ignore this
+			break;
+		case 0x3d: // Set MSB to 0 (ESC =)
+			msb = 0;
+			break;
+		case 0x3e: // Set MSB to 1 (ESC >)
+			msb = 1;
+			break;
+		case 0x3f: // Reassign bit-image mode (ESC ?)
+			if (params[0] == 75)
+				densk = params[1];
+			if (params[0] == 76)
+				densl = params[1];
+			if (params[0] == 89)
+				densy = params[1];
+			if (params[0] == 90)
+				densz = params[1];
+			break;
+		case 0x40: // Initialize printer (ESC @)
+			resetPrinter();
+			break;
+		case 0x41: // Set n/60-inch line spacing
+		case 0x841:
+			lineSpacing = (Real64)params[0]/60;
+			break;
+		case 0x43: // Set page length in lines (ESC C)
+			if (params[0] != 0)
+				pageHeight = bottomMargin = (Real64)params[0] * lineSpacing;
+			else // == 0 => Set page length in inches
+			{
+				neededParam = 1;
+				numParam = 0;
+				ESCCmd = 0x100;
+				return true;
+			}
+			break;
+		case 0x45: // Select bold font (ESC E)
+			style |= STYLE_BOLD;
+			updateFont();
+			break;
+		case 0x46: // Cancel bold font (ESC F)
+			style &= ~STYLE_BOLD;
+			updateFont();
+			break;
+		case 0x47: // Select dobule-strike printing (ESC G)
+			style |= STYLE_DOUBLESTRIKE;
+			break;
+		case 0x48: // Cancel double-strike printing (ESC H)
+			style &= ~STYLE_DOUBLESTRIKE;
+			break;
+		case 0x4a: // Advance print position vertically (ESC J n)
+			curY += (Real64)((Real64)params[0] / 180);
+			if (curY > bottomMargin)
+				newPage(true,false);
+			break;
+		case 0x4b: // Select 60-dpi graphics (ESC K)
+			setupBitImage(densk, PARAM16(0));
+			break;
+		case 0x4c: // Select 120-dpi graphics (ESC L)
+			setupBitImage(densl, PARAM16(0));
+			break;
+		case 0x4d: // Select 10.5-point, 12-cpi (ESC M)
+			cpi = 12;
+			hmi = -1;
+			multipoint = false;
+			updateFont();
+			break;
+		case 0x4e: // Set bottom margin (ESC N)
+			topMargin = 0.0;
+			bottomMargin = (Real64)params[0] * lineSpacing; 
+			break;
+		case 0x4f: // Cancel bottom (and top) margin
+			topMargin = 0.0;
+			bottomMargin = pageHeight;
+			break;
+		case 0x50: // Select 10.5-point, 10-cpi (ESC P)
+			cpi = 10;
+			hmi = -1;
+			multipoint = false;
+			updateFont();
+			break;
+		case 0x51: // Set right margin
+			rightMargin = (Real64)(params[0]-1.0) / (Real64)cpi;
+			break;
+		case 0x52: // Select an international character set (ESC R)
+			if (params[0] <= 13 || params[0] == 64)
+			{
+				if (params[0] == 64)
+					params[0] = 14;
+
+				curMap[0x23] = intCharSets[params[0]][0];
+				curMap[0x24] = intCharSets[params[0]][1];
+				curMap[0x40] = intCharSets[params[0]][2];
+				curMap[0x5b] = intCharSets[params[0]][3];
+				curMap[0x5c] = intCharSets[params[0]][4];
+				curMap[0x5d] = intCharSets[params[0]][5];
+				curMap[0x5e] = intCharSets[params[0]][6];
+				curMap[0x60] = intCharSets[params[0]][7];
+				curMap[0x7b] = intCharSets[params[0]][8];
+				curMap[0x7c] = intCharSets[params[0]][9];
+				curMap[0x7d] = intCharSets[params[0]][10];
+				curMap[0x7e] = intCharSets[params[0]][11];
+			}
+			break;
+		case 0x53: // Select superscript/subscript printing (ESC S)
+			if (params[0] == 0 || params[0] == 48)
+				style |= STYLE_SUBSCRIPT;
+			if (params[0] == 1 || params[1] == 49)
+				style |= STYLE_SUPERSCRIPT;
+			updateFont();
+			break;
+		case 0x54: // Cancel superscript/subscript printing (ESC T)
+			style &= 0xFFFF - STYLE_SUPERSCRIPT - STYLE_SUBSCRIPT;
+			updateFont();
+			break;
+		case 0x55: // Turn unidirectional mode on/off (ESC U)
+			// We don't have a print head, so just ignore this
+			break;
+		case 0x57: // Turn double-width printing on/off (ESC W)
+			if (!multipoint)
+			{
+				hmi = -1;
+				if (params[0] == 0 || params[0] == 48)
+					style &= ~STYLE_DOUBLEWIDTH;
+				if (params[0] == 1 || params[0] == 49)
+					style |= STYLE_DOUBLEWIDTH;
+				updateFont();
+			}
+			break;
+		case 0x58: // Select font by pitch and point (ESC X)
+			multipoint = true;
+			// Copy currently non-multipoint CPI if no value was set so far
+			if (multicpi == 0)
+				multicpi = cpi;
+			if (params[0] > 0)  // Set CPI
+			{
+				if (params[0] == 1) // Proportional spacing
+					style |= STYLE_PROP;
+				else if (params[0] >= 5)
+					multicpi = (Real64)360 / (Real64)params[0];
+			}
+			if (multiPointSize == 0)
+				multiPointSize = (Real64)10.5;
+			if (PARAM16(1) > 0) // Set points
+				multiPointSize = ((Real64)PARAM16(1)) / 2;			
+			updateFont();
+			break;
+		case 0x59: // Select 120-dpi, double-speed graphics (ESC Y)
+			setupBitImage(densy, PARAM16(0));
+			break;
+		case 0x5a: // Select 240-dpi graphics (ESC Z)
+			setupBitImage(densz, PARAM16(0));
+			break;
+		case 0x5c: // Set relative horizontal print position (ESC \)
+			{
+				Bit16s toMove = PARAM16(0);
+				Real64 unitSize = definedUnit;
+				if (unitSize < 0)
+					unitSize = (Real64)(printQuality==QUALITY_DRAFT?120.0:180.0);
+				curX += (Real64)((Real64)toMove / unitSize);
+			}
+			break;
+		case 0x61: // Select justification (ESC a)
+			// Ignore
+			break;
+		case 0x63: // Set horizontal motion index (HMI) (ESC c)
+			hmi = (Real64)PARAM16(0) / (Real64)360.0;
+			extraIntraSpace = 0.0;
+			break;
+		case 0x67: // Select 10.5-point, 15-cpi (ESC g)
+			cpi = 15;
+			hmi = -1;
+			multipoint = false;
+			updateFont();
+			break;
+		case 0x846: // Select forward feed mode (FS F) - set reverse not implemented yet
+			if(lineSpacing < 0) lineSpacing *= -1;
+			break;
+		case 0x6a: // Reverse paper feed (ESC j)
+			{
+				Real64 reverse = (Real64)PARAM16(0) / (Real64)216.0;
+				reverse = curY - reverse;
+				if(reverse < leftMargin) curY = leftMargin;
+				else curY = reverse;
+				break;
+			}
+		case 0x6b: // Select typeface (ESC k)
+			if (params[0] <= 11 || params[0] == 30 || params[0] == 31) 
+				LQtypeFace = (Typeface)params[0];
+			updateFont();
+			break;
+		case 0x6c: // Set left margin (ESC l)
+			leftMargin =  (Real64)(params[0]-1.0) / (Real64)cpi;
+			if (curX < leftMargin)
+				curX = leftMargin;
+			break;
+		case 0x70: // Turn proportional mode on/off (ESC p)
+			if (params[0] == 0 || params[0] == 48)
+				style &= (0xffff - STYLE_PROP);
+			if (params[0] == 1 || params[0] == 49)
+			{
+				style |= STYLE_PROP;
+				printQuality = QUALITY_LQ;
+			}
+			multipoint = false;
+			hmi = -1;
+			updateFont();
+			break;
+		case 0x72: // Select printing color (ESC r)
+			
+			if(params[0]==0 || params[0] > 6) color = COLOR_BLACK;
+			else color = params[0]<<5;       
+			break;
+		case 0x73: // Select low-speed mode (ESC s)
+			// Ignore
+			break;
+		case 0x74: // Select character table (ESC t)
+		case 0x849: // Select character table (FS I)
+			if (params[0] < 4)
+				curCharTable = params[0];
+			if (params[0] >= 48 && params[0] <= 51)
+				curCharTable = params[0] - 48;
+			selectCodepage(charTables[curCharTable]);
+			updateFont();
+			break;
+		case 0x77: // Turn double-height printing on/off (ESC w)
+			if (!multipoint)
+			{
+				if (params[0] == 0 || params[0] == 48)
+					style &= ~STYLE_DOUBLEHEIGHT;
+				if (params[0] == 1 || params[0] == 49)
+					style |= STYLE_DOUBLEHEIGHT;
+				updateFont();
+			}
+			break;
+		case 0x78: // Select LQ or draft (ESC x)
+			if (params[0] == 0 || params[0] == 48) {
+				printQuality = QUALITY_DRAFT;
+				style |= STYLE_CONDENSED;
+			}
+			if (params[0] == 1 || params[0] == 49) {
+				printQuality = QUALITY_LQ;
+				style &= ~STYLE_CONDENSED;
+			}
+			hmi = -1;
+			updateFont();
+			break;
+		case 0x100: // Set page length in inches (ESC C NUL)
+			pageHeight = (Real64)params[0];
+			bottomMargin = pageHeight;
+			topMargin = 0.0;
+			break;
+		case 0x101: // Skip unsupported ESC ( command
+			neededParam = PARAM16(0);
+			numParam = 0;
+			break;
+		case 0x274: // Assign character table (ESC (t)
+			if (params[2] < 4 && params[3] < 16)
+			{
+				charTables[params[2]] = codepages[params[3]];
+				//LOG_MSG("curr table: %d, p2: %d, p3: %d",curCharTable,params[2],params[3]);
+				if (params[2] == curCharTable)
+					selectCodepage(charTables[curCharTable]);
+			}
+			break;
+		case 0x22d: // Select line/score (ESC (-) 
+			style &= ~(STYLE_UNDERLINE | STYLE_STRIKETHROUGH | STYLE_OVERSCORE);
+			score = params[4];
+			if (score)
+			{
+				if (params[3] == 1)
+					style |= STYLE_UNDERLINE;
+				if (params[3] == 2)
+					style |= STYLE_STRIKETHROUGH;
+				if (params[3] == 3)
+					style |= STYLE_OVERSCORE;
+			}
+			updateFont();
+			break;
+		case 0x242: // Bar code setup and print (ESC (B)
+			LOG(LOG_MISC,LOG_ERROR)("PRINTER: Bardcode printing not supported");
+			// Find out how many bytes to skip
+			neededParam = PARAM16(0);
+			numParam = 0;
+			break;
+		case 0x243: // Set page length in defined unit (ESC (C)
+			if (params[0] != 0 && definedUnit > 0)
+			{
+				pageHeight = bottomMargin = ((Real64)PARAM16(2)) * definedUnit;
+				topMargin = 0.0;
+			}
+			break;
+		case 0x255: // Set unit (ESC (U)
+			definedUnit = (Real64)params[2] / (Real64)3600;
+			break;
+		case 0x256: // Set absolute vertical print position (ESC (V)
+			{
+				Real64 unitSize = definedUnit;
+				if (unitSize < 0)
+					unitSize = (Real64)360.0;
+				Real64 newPos = topMargin + (((Real64)PARAM16(2)) * unitSize);
+				if (newPos > bottomMargin)
+					newPage(true,false);
+				else
+					curY = newPos;
+			}
+			break;
+		case 0x25e: // Print data as characters (ESC (^)
+			numPrintAsChar = PARAM16(0);
+			break;
+		case 0x263: // Set page format (ESC (c)
+			if (definedUnit > 0)
+			{
+				Real64 newTop, newBottom;
+				newTop = ((Real64)PARAM16(2)) * definedUnit;
+				newBottom = ((Real64)PARAM16(4)) * definedUnit;
+				if(newTop >= newBottom) break;
+				if(newTop < pageHeight) topMargin = newTop;
+				if(newBottom < pageHeight) bottomMargin = newBottom;
+				if(topMargin > curY) curY = topMargin;
+				//LOG_MSG("du %d, p1 %d, p2 %d, newtop %f, newbott %f, nt %f, nb %f, ph %f",
+				//	(Bitu)definedUnit,PARAM16(2),PARAM16(4),topMargin,bottomMargin,
+				//	newTop,newBottom,pageHeight);
+			}
+			break;
+		case 0x276: // Set relative vertical print position (ESC (v)
+			{
+				Real64 unitSize = definedUnit;
+				if (unitSize < 0)
+					unitSize = (Real64)360.0;
+				Real64 newPos = curY + ((Real64)((Bit16s)PARAM16(2)) * unitSize);
+				if (newPos > topMargin)
+				{
+					if (newPos > bottomMargin)
+						newPage(true,false);
+					else
+						curY = newPos;	
+				}
+			}
+			break;
+		default:
+			if (ESCCmd < 0x100)
+				//LOG(LOG_MISC,LOG_WARN)
+				LOG_MSG("PRINTER: Skipped unsupported command ESC %c (%02X)", ESCCmd, ESCCmd);
+			else
+				//LOG(LOG_MISC,LOG_WARN)
+				LOG_MSG("PRINTER: Skipped unsupported command ESC ( %c (%02X)", ESCCmd-0x200, ESCCmd-0x200);
+		}
+
+		ESCCmd = 0;
+		return true;
+	}
+
+	switch (ch)
+	{
+	case 0x00:  // NUL is ignored by the printer
+		return true;
+	case 0x07:  // Beeper (BEL)
+		// BEEEP!
+		return true;
+	case 0x08:	// Backspace (BS)
+		{
+			Real64 newX = curX - (1/(Real64)actcpi);
+			if (hmi > 0)
+				newX = curX - hmi;
+			if (newX >= leftMargin)
+				curX = newX;
+		}
+		return true;
+	case 0x09:	// Tab horizontally (HT)
+		{
+			// Find tab right to current pos
+			Real64 moveTo = -1;
+			for (Bit8u i=0; i<numHorizTabs; i++)
+				if (horiztabs[i] > curX)
+					moveTo = horiztabs[i];
+			// Nothing found => Ignore
+			if (moveTo > 0 && moveTo < rightMargin)
+				curX = moveTo;
+		}
+		return true;
+	case 0x0b:	// Tab vertically (VT)
+		if (numVertTabs == 0) // All tabs cancelled => Act like CR
+			curX = leftMargin;
+		else if (numVertTabs == 255) // No tabs set since reset => Act like LF
+		{
+			curX = leftMargin;
+			curY += lineSpacing;
+			if (curY > bottomMargin)
+				newPage(true,false);
+		}
+		else
+		{
+			// Find tab below current pos
+			Real64 moveTo = -1;
+			for (Bit8u i=0; i<numVertTabs; i++)
+				if (verttabs[i] > curY)
+					moveTo = verttabs[i];
+
+			// Nothing found => Act like FF
+			if (moveTo > bottomMargin || moveTo < 0)
+				newPage(true,false);
+			else
+				curY = moveTo;
+		}
+		if (style & STYLE_DOUBLEWIDTHONELINE)
+		{
+			style &= 0xFFFF - STYLE_DOUBLEWIDTHONELINE;
+			updateFont();
+		}
+		return true;
+	case 0x0c:		// Form feed (FF)
+		if (style & STYLE_DOUBLEWIDTHONELINE)
+		{
+			style &= 0xFFFF - STYLE_DOUBLEWIDTHONELINE;
+			updateFont();
+		}
+		newPage(true,true);
+		return true;
+	case 0x0d:		// Carriage Return (CR)
+		curX = leftMargin;
+		if (!autoFeed)
+			return true;
+	case 0x0a:		// Line feed
+		if (style & STYLE_DOUBLEWIDTHONELINE)
+		{
+			style &= 0xFFFF - STYLE_DOUBLEWIDTHONELINE;
+			updateFont();
+		}
+		curX = leftMargin;
+		curY += lineSpacing;
+		if (curY > bottomMargin)
+			newPage(true,false);
+		return true;
+	case 0x0e:		//Select Real64-width printing (one line) (SO)
+		if (!multipoint)
+		{
+			hmi = -1;
+			style |= STYLE_DOUBLEWIDTHONELINE;
+			updateFont();
+		}
+		return true;
+	case 0x0f:		// Select condensed printing (SI)
+		if (!multipoint && (cpi!=15.0)) {
+			hmi = -1;
+			style |= STYLE_CONDENSED;
+			updateFont();
+		}
+		return true;
+	case 0x11:		// Select printer (DC1)
+		// Ignore
+		return true;
+	case 0x12:		// Cancel condensed printing (DC2)
+		hmi = -1;
+		style &= ~STYLE_CONDENSED;
+		updateFont();
+		return true;
+	case 0x13:		// Deselect printer (DC3)
+		// Ignore
+		return true;
+	case 0x14:		// Cancel double-width printing (one line) (DC4)
+		hmi = -1;
+		style &= ~STYLE_DOUBLEWIDTHONELINE;
+		updateFont();
+		return true;
+	case 0x18:		// Cancel line (CAN)
+		return true;
+	case 0x1b:		// ESC
+		ESCSeen = true;
+		return true;
+	case 0x1c:		// FS (IBM commands)
+		FSSeen = true;
+		return true;
+	default:
+		return false;
+	}
+
+	return false;
+}
+
+static void PRINTER_EventHandler(Bitu param);
+
+void CPrinter::newPage(bool save, bool resetx)
+{
+	PIC_RemoveEvents(PRINTER_EventHandler);
+	if(printer_timout) timeout_dirty=false;
+
+	if (save)
+		outputPage();
+
+	if(resetx) curX=leftMargin;
+	curY = topMargin;
+
+	SDL_Rect rect;
+	rect.x = 0;
+	rect.y = 0;
+	rect.w = page->w;
+	rect.h = page->h;
+	SDL_FillRect(page, &rect, SDL_MapRGB(page->format, 255, 255, 255));
+
+	/*for(int i = 0; i < 256; i++)
+	{
+        *((Bit8u*)page->pixels+i)=i;
+	}*/
+}
+
+void CPrinter::printChar(Bit8u ch)
+{
+	charRead = true;
+	if (page == NULL) return;
+
+	// Don't think that DOS programs uses this but well: Apply MSB if desired
+	if (msb != 255) {
+		if (msb == 0) ch &= 0x7F;
+		if (msb == 1) ch |= 0x80;
+	}
+
+	// Are we currently printing a bit graphic?
+	if (bitGraph.remBytes > 0) {
+		printBitGraph(ch);
+		return;
+	}
+
+	// Print everything?
+	if (numPrintAsChar > 0) numPrintAsChar--;
+	else if (processCommandChar(ch)) return;
+
+	// Do not print if no font is available
+	if (!curFont) return;
+
+	if(ch==0x1) ch=0x20;
+	
+	// Find the glyph for the char to render
+	FT_UInt index = FT_Get_Char_Index(curFont, curMap[ch]);
+	
+	// Load the glyph 
+	FT_Load_Glyph(curFont, index, FT_LOAD_DEFAULT);
+
+	// Render a high-quality bitmap
+	FT_Render_Glyph(curFont->glyph, FT_RENDER_MODE_NORMAL);
+
+	Bit16u penX = PIXX + curFont->glyph->bitmap_left;
+	Bit16u penY = PIXY - curFont->glyph->bitmap_top + curFont->size->metrics.ascender/64;
+
+	if (style & STYLE_SUBSCRIPT) penY += curFont->glyph->bitmap.rows / 2;
+
+	// Copy bitmap into page
+	SDL_LockSurface(page);
+
+	blitGlyph(curFont->glyph->bitmap, penX, penY, false);
+	blitGlyph(curFont->glyph->bitmap, penX+1, penY, true);
+
+	// Doublestrike => Print the glyph a second time one pixel below
+	if (style & STYLE_DOUBLESTRIKE) {
+		blitGlyph(curFont->glyph->bitmap, penX, penY+1, true);
+		blitGlyph(curFont->glyph->bitmap, penX+1, penY+1, true);
+	}
+
+	// Bold => Print the glyph a second time one pixel to the right
+	// or be a bit more bold...
+	if (style & STYLE_BOLD) {
+		blitGlyph(curFont->glyph->bitmap, penX+1, penY, true);
+		blitGlyph(curFont->glyph->bitmap, penX+2, penY, true);
+		blitGlyph(curFont->glyph->bitmap, penX+3, penY, true);
+	}
+	SDL_UnlockSurface(page);
+
+	// For line printing
+	Bit16u lineStart = PIXX;
+
+	// advance the cursor to the right
+	Real64 x_advance;
+	if (style &	STYLE_PROP)
+		x_advance = (Real64)((Real64)(curFont->glyph->advance.x)/(Real64)(dpi*64));
+	else {
+		if (hmi < 0) x_advance = 1/(Real64)actcpi;
+		else x_advance = hmi;
+	}
+	x_advance += extraIntraSpace;
+    curX += x_advance;
+
+	// Draw lines if desired
+	if ((score != SCORE_NONE) && (style & 
+		(STYLE_UNDERLINE|STYLE_STRIKETHROUGH|STYLE_OVERSCORE)))
+	{
+		// Find out where to put the line
+		Bit16u lineY = PIXY;
+		double height = (curFont->size->metrics.height>>6); // TODO height is fixed point madness...
+
+		if (style & STYLE_UNDERLINE) lineY = PIXY + (Bit16u)(height*0.9);
+		else if (style & STYLE_STRIKETHROUGH) lineY = PIXY + (Bit16u)(height*0.45);
+		else if (style & STYLE_OVERSCORE)
+			lineY = PIXY - (((score == SCORE_DOUBLE)||(score == SCORE_DOUBLEBROKEN))?5:0);
+
+		drawLine(lineStart, PIXX, lineY, score==SCORE_SINGLEBROKEN || score==SCORE_DOUBLEBROKEN);
+
+		// draw second line if needed
+		if ((score == SCORE_DOUBLE)||(score == SCORE_DOUBLEBROKEN))
+			drawLine(lineStart, PIXX, lineY + 5, score==SCORE_SINGLEBROKEN || score==SCORE_DOUBLEBROKEN);
+	}
+	// If the next character would go beyond the right margin, line-wrap.
+	if((curX + x_advance) > rightMargin) {
+		curX = leftMargin;
+		curY += lineSpacing;
+		if (curY > bottomMargin) newPage(true,false);
+	}
+}
+
+void CPrinter::blitGlyph(FT_Bitmap bitmap, Bit16u destx, Bit16u desty, bool add) {
+	for (Bitu y=0; y<bitmap.rows; y++) {
+		for (Bitu x=0; x<bitmap.width; x++) {
+			// Read pixel from glyph bitmap
+			Bit8u source = *(bitmap.buffer + x + y*bitmap.pitch);
+
+			// Ignore background and don't go over the border
+			if (source > 0 && (destx+x < page->w) && (desty+y < page->h) ) {
+				Bit8u* target = (Bit8u*)page->pixels + (x+destx) + (y+desty)*page->pitch;
+				source>>=3;
+				
+				if (add) {
+					if (((*target)&0x1f )+ source > 31) *target |= (color|0x1f);
+					else {
+						*target += source;
+						*target |= color;
+					}
+				}
+				else *target = source|color;
+			}
+		}
+	}
+}
+
+void CPrinter::drawLine(Bitu fromx, Bitu tox, Bitu y, bool broken)
+{
+	SDL_LockSurface(page);
+
+	Bitu breakmod = dpi / 15;
+	Bitu gapstart = (breakmod * 4)/5;
+
+	// Draw anti-aliased line
+	for (Bitu x=fromx; x<=tox; x++)
+	{
+		// Skip parts if broken line or going over the border
+		if ((!broken || (x%breakmod <= gapstart)) && (x < page->w))
+		{
+			if (y > 0 && (y-1) < page->h)
+				*((Bit8u*)page->pixels + x + (y-1)*page->pitch) = 240;
+			if (y < page->h)
+				*((Bit8u*)page->pixels + x + y*page->pitch) = !broken?255:240;
+			if (y+1 < page->h)
+				*((Bit8u*)page->pixels + x + (y+1)*page->pitch) = 240;
+		}
+	}
+	SDL_UnlockSurface(page);
+}
+
+void CPrinter::setAutofeed(bool feed) {
+	autoFeed = feed;
+}
+
+bool CPrinter::getAutofeed() {
+	return autoFeed;
+}
+
+bool CPrinter::isBusy() {
+	// We're never busy
+	return false;
+}
+
+bool CPrinter::ack() {
+	// Acknowledge last char read
+	if(charRead) {
+		charRead=false;
+		return true;
+	}
+	return false;
+}
+
+void CPrinter::setupBitImage(Bit8u dens, Bit16u numCols) {
+	switch (dens)
+	{
+	case 0:
+		bitGraph.horizDens = 60;
+		bitGraph.vertDens = 60;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 1:
+		bitGraph.horizDens = 120;
+		bitGraph.vertDens = 60;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 2:
+		bitGraph.horizDens = 120;
+		bitGraph.vertDens = 60;
+		bitGraph.adjacent = false;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 3:
+		bitGraph.horizDens = 60;
+		bitGraph.vertDens = 240;
+		bitGraph.adjacent = false;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 4:
+		bitGraph.horizDens = 80;
+		bitGraph.vertDens = 60;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 6:
+		bitGraph.horizDens = 90;
+		bitGraph.vertDens = 60;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 32:
+		bitGraph.horizDens = 60;
+		bitGraph.vertDens = 180;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 3;
+		break;
+	case 33:
+		bitGraph.horizDens = 120;
+		bitGraph.vertDens = 180;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 3;
+		break;
+	case 38:
+		bitGraph.horizDens = 90;
+		bitGraph.vertDens = 180;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 3;
+		break;
+	case 39:
+		bitGraph.horizDens = 180;
+		bitGraph.vertDens = 180;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 3;
+		break;
+	case 40:
+		bitGraph.horizDens = 360;
+		bitGraph.vertDens = 180;
+		bitGraph.adjacent = false;
+		bitGraph.bytesColumn = 3;
+		break;
+	case 71:
+		bitGraph.horizDens = 180;
+		bitGraph.vertDens = 360;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 6;
+		break;
+	case 72:
+		bitGraph.horizDens = 360;
+		bitGraph.vertDens = 360;
+		bitGraph.adjacent = false;
+		bitGraph.bytesColumn = 6;
+		break;
+	case 73:
+		bitGraph.horizDens = 360;
+		bitGraph.vertDens = 360;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 6;
+		break;
+	default:
+		LOG(LOG_MISC,LOG_ERROR)("PRINTER: Unsupported bit image density %i", dens);
+	}
+
+	bitGraph.remBytes = numCols * bitGraph.bytesColumn;
+	bitGraph.readBytesColumn = 0;
+}
+
+void CPrinter::printBitGraph(Bit8u ch)
+{
+	bitGraph.column[bitGraph.readBytesColumn++] = ch;
+	bitGraph.remBytes--;
+
+	// Only print after reading a full column
+	if (bitGraph.readBytesColumn < bitGraph.bytesColumn)
+		return;
+
+	Real64 oldY = curY;
+
+	SDL_LockSurface(page);
+
+	// When page dpi is greater than graphics dpi, the drawn pixels get "bigger"
+	Bitu pixsizeX=1; 
+	Bitu pixsizeY=1;
+	if(bitGraph.adjacent) {
+		pixsizeX = dpi/bitGraph.horizDens > 0? dpi/bitGraph.horizDens : 1;
+		pixsizeY = dpi/bitGraph.vertDens > 0? dpi/bitGraph.vertDens : 1;
+	}
+	// TODO figure this out for 360dpi mode in windows
+
+//	Bitu pixsizeX = dpi/bitGraph.horizDens > 0? dpi/bitGraph.horizDens : 1;
+//	Bitu pixsizeY = dpi/bitGraph.vertDens > 0? dpi/bitGraph.vertDens : 1;
+
+	for (Bitu i=0; i<bitGraph.bytesColumn; i++) // for each byte
+	{
+		for (Bitu j=128; j!=0; j>>=1) { // for each bit
+			if (bitGraph.column[i] & j) {
+				for (Bitu xx=0; xx<pixsizeX; xx++)
+					for (Bitu yy=0; yy<pixsizeY; yy++) {
+						if (((PIXX + xx) < page->w) && ((PIXY + yy) < page->h))
+							*((Bit8u*)page->pixels + (PIXX+xx) + (PIXY+yy)*page->pitch) |= (color|0x1F);
+					}
+			} // else white pixel
+
+			curY += (Real64)1/(Real64)bitGraph.vertDens; // TODO line wrap?
+		}
+	}
+
+	SDL_UnlockSurface(page);
+
+	curY = oldY;
+
+	bitGraph.readBytesColumn = 0;
+
+	// Advance to the left
+	curX += (Real64)1/(Real64)bitGraph.horizDens;
+}
+
+void CPrinter::formFeed()
+{
+	// Don't output blank pages
+	newPage(!isBlank(),true);
+
+	finishMultipage();
+}
+
+static void findNextName(char* front, char* ext, char* fname)
+{
+	Bitu i = 1;
+	Bitu slen = strlen(document_path);
+	if(slen>(200-15)) {
+		fname[0]=0;
+		return;
+	}
+	FILE *test = NULL;
+	do
+	{
+		strcpy(fname, document_path);
+#ifdef WIN32
+		const char* const pathstring = "\\%s%d%s";
+#else 
+		const char* const pathstring = "/%s%d%s";
+#endif
+		sprintf(fname+strlen(fname), pathstring, front,i++,ext);
+		test = fopen(fname, "rb");
+		if (test != NULL)
+			fclose(test);
+	}
+	while (test != NULL );
+}
+
+void CPrinter::outputPage() 
+{
+	char fname[200]; 
+
+	if (strcasecmp(output, "printer") == 0)
+	{
+#if defined (WIN32)
+		// You'll need the mouse for the print dialog
+		if(mouselocked)
+			 GFX_CaptureMouse();
+
+		Bit16u physW = GetDeviceCaps(printerDC, PHYSICALWIDTH);
+		Bit16u physH = GetDeviceCaps(printerDC, PHYSICALHEIGHT);
+
+		Real64 scaleW, scaleH;
+
+		if (page->w > physW) 
+	        scaleW = (Real64)page->w / (Real64)physW;
+	    else 
+			scaleW = (Real64)physW / (Real64)page->w; 
+ 
+		if (page->h > physH) 
+	        scaleH = (Real64)page->h / (Real64)physH;
+	    else 
+			scaleH = (Real64)physH / (Real64)page->h; 
+
+		HDC memHDC = CreateCompatibleDC(printerDC);
+		HBITMAP bitmap = CreateCompatibleBitmap(memHDC, page->w, page->h);
+		SelectObject(memHDC, bitmap);
+
+		// Start new printer job?
+		if (outputHandle == NULL)
+		{
+			DOCINFO docinfo;
+			memset(&docinfo, 0, sizeof(docinfo));
+			docinfo.cbSize = sizeof(docinfo);
+			docinfo.lpszDocName = "DOSBOX Printer";
+			docinfo.lpszOutput = NULL;
+			docinfo.lpszDatatype = NULL;
+			docinfo.fwType = 0;
+
+			StartDoc(printerDC, &docinfo);
+			multiPageCounter = 1;
+		}
+
+		if (StartPage(printerDC) < 0) {
+			LOG_MSG("PRINTER: Cannot start page.");
+			DeleteObject(bitmap);
+			DeleteDC(memHDC);
+			return;
+		}
+		SDL_LockSurface(page);
+
+		SDL_Palette* sdlpal = page->format->palette;
+
+		for (Bit16u y=0; y<page->h; y++)
+		{
+			for (Bit16u x=0; x<page->w; x++)
+			{
+				Bit8u pixel = *((Bit8u*)page->pixels + x + (y*page->pitch));
+				Bit32u color = 0;
+				color |= sdlpal->colors[pixel].r;
+				color |= ((Bit32u)sdlpal->colors[pixel].g) << 8;
+				color |= ((Bit32u)sdlpal->colors[pixel].b) << 16;
+				SetPixel(memHDC, x, y, color);
+			}
+		}
+
+		SDL_UnlockSurface(page);
+	
+		StretchBlt(printerDC, 0, 0, physW, physH, memHDC, 0, 0, page->w, page->h, SRCCOPY);
+
+		EndPage(printerDC);
+
+		if (multipageOutput)
+		{
+			multiPageCounter++;
+			outputHandle = printerDC;
+		}
+		else
+		{
+			EndDoc(printerDC);
+			outputHandle = NULL;
+		}
+		DeleteObject(bitmap);
+		DeleteDC(memHDC);
+#else
+		LOG_MSG("PRINTER: Direct printing not supported under this OS");
+#endif
+	}
+#ifdef C_LIBPNG
+	else if (strcasecmp(output, "png") == 0)
+	{
+		// Find a page that does not exists
+		findNextName("page", ".png", &fname[0]);
+	
+		png_structp png_ptr;
+		png_infop info_ptr;
+		png_bytep * row_pointers;
+		png_color palette[256];
+		Bitu i;
+
+		/* Open the actual file */
+		FILE * fp=fopen(fname,"wb");
+		if (!fp) 
+		{
+			LOG(LOG_MISC,LOG_ERROR)("PRINTER: Can't open file %s for printer output", fname);
+			return;
+		}
+
+		/* First try to alloacte the png structures */
+		png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL,NULL, NULL);
+		if (!png_ptr) return;
+		info_ptr = png_create_info_struct(png_ptr);
+		if (!info_ptr) {
+			png_destroy_write_struct(&png_ptr,(png_infopp)NULL);
+			return;
+		}
+
+		/* Finalize the initing of png library */
+		png_init_io(png_ptr, fp);
+		png_set_compression_level(png_ptr,Z_BEST_COMPRESSION);
+		
+		/* set other zlib parameters */
+		png_set_compression_mem_level(png_ptr, 8);
+		png_set_compression_strategy(png_ptr,Z_DEFAULT_STRATEGY);
+		png_set_compression_window_bits(png_ptr, 15);
+		png_set_compression_method(png_ptr, 8);
+		png_set_compression_buffer_size(png_ptr, 8192);
+
+		
+		png_set_IHDR(png_ptr, info_ptr, page->w, page->h,
+			8, PNG_COLOR_TYPE_PALETTE, PNG_INTERLACE_NONE,
+			PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
+		for (i=0;i<256;i++) 
+		{
+			palette[i].red = page->format->palette->colors[i].r;
+			palette[i].green = page->format->palette->colors[i].g;
+			palette[i].blue = page->format->palette->colors[i].b;
+		}
+		png_set_PLTE(png_ptr, info_ptr, palette,256);
+		
+		SDL_LockSurface(page);
+
+		// Allocate an array of scanline pointers
+		row_pointers = (png_bytep*)malloc(page->h*sizeof(png_bytep));
+		for (i=0; i<page->h; i++) 
+			row_pointers[i] = ((Bit8u*)page->pixels+(i*page->pitch));
+
+		// tell the png library what to encode.
+		png_set_rows(png_ptr, info_ptr, row_pointers);
+		
+		// Write image to file
+		png_write_png(png_ptr, info_ptr, 0, NULL);
+
+		SDL_UnlockSurface(page);
+		
+		/*close file*/
+		fclose(fp);
+	
+		/*Destroy PNG structs*/
+		png_destroy_write_struct(&png_ptr, &info_ptr);
+		
+		/*clean up dynamically allocated RAM.*/
+		free(row_pointers);
+	}
+#endif
+	else if (strcasecmp(output, "ps") == 0)
+	{
+		FILE* psfile = NULL;
+		
+		// Continue postscript file?
+		if (outputHandle != NULL)
+			psfile = (FILE*)outputHandle;
+
+		// Create new file?
+		if (psfile == NULL)
+		{
+			if (!multipageOutput)
+				findNextName("page", ".ps", &fname[0]);
+			else
+				findNextName("doc", ".ps", &fname[0]);
+
+			psfile = fopen(fname, "wb");
+			if (!psfile) 
+			{
+				LOG(LOG_MISC,LOG_ERROR)("PRINTER: Can't open file %s for printer output", fname);
+				return;
+			}
+
+			// Print header
+			fprintf(psfile, "%%!PS-Adobe-3.0\n");
+			fprintf(psfile, "%%%%Pages: (atend)\n");
+			fprintf(psfile, "%%%%BoundingBox: 0 0 %i %i\n", (Bit16u)(defaultPageWidth*74), (Bit16u)(defaultPageHeight*74));
+			fprintf(psfile, "%%%%Creator: DOSBOX Virtual Printer\n");
+			fprintf(psfile, "%%%%DocumentData: Clean7Bit\n");
+			fprintf(psfile, "%%%%LanguageLevel: 2\n");
+			fprintf(psfile, "%%%%EndComments\n");
+			multiPageCounter = 1;
+		}
+
+		fprintf(psfile, "%%%%Page: %i %i\n", multiPageCounter, multiPageCounter);
+		fprintf(psfile, "%i %i scale\n", (Bit16u)(defaultPageWidth*74), (Bit16u)(defaultPageHeight*74));
+		fprintf(psfile, "%i %i 8 [%i 0 0 -%i 0 %i]\n", page->w, page->h, page->w, page->h, page->h);
+		fprintf(psfile, "currentfile\n");
+		fprintf(psfile, "/ASCII85Decode filter\n");
+		fprintf(psfile, "/RunLengthDecode filter\n");
+		fprintf(psfile, "image\n");
+
+		SDL_LockSurface(page);
+
+		Bit32u pix = 0;
+		Bit32u numpix = page->h*page->w;
+		ASCII85BufferPos = ASCII85CurCol = 0;
+
+		while (pix < numpix)
+		{
+			// Compress data using RLE
+
+			if ((pix < numpix-2) && (getPixel(pix) == getPixel(pix+1)) && (getPixel(pix) == getPixel(pix+2)))
+			{
+				// Found three or more pixels with the same color
+				Bit8u sameCount = 3;
+				Bit8u col = getPixel(pix);
+				while (sameCount < 128 && sameCount+pix < numpix && col == getPixel(pix+sameCount))
+					sameCount++;
+
+				fprintASCII85(psfile, 257-sameCount);
+				fprintASCII85(psfile, 255-col);
+
+				// Skip ahead
+				pix += sameCount;
+			}
+			else
+			{
+				// Find end of heterogenous area
+				Bit8u diffCount = 1;
+				while (diffCount < 128 && diffCount+pix < numpix && 
+					(
+						   (diffCount+pix < numpix-2)
+						|| (getPixel(pix+diffCount) != getPixel(pix+diffCount+1))
+						|| (getPixel(pix+diffCount) != getPixel(pix+diffCount+2))
+					))
+					diffCount++;
+
+				fprintASCII85(psfile, diffCount-1);
+				for (Bit8u i=0; i<diffCount; i++)
+					fprintASCII85(psfile, 255-getPixel(pix++));
+			}
+		}
+
+		// Write EOD for RLE and ASCII85
+		fprintASCII85(psfile, 128);
+		fprintASCII85(psfile, 256);
+
+		SDL_UnlockSurface(page);
+
+		fprintf(psfile, "showpage\n");
+
+		if (multipageOutput)
+		{
+			multiPageCounter++;
+			outputHandle = psfile;
+		}
+		else
+		{
+			fprintf(psfile, "%%%%Pages: 1\n");
+			fprintf(psfile, "%%%%EOF\n");
+			fclose(psfile);
+			outputHandle = NULL;
+		}
+	}
+	else
+	{	
+		// Find a page that does not exists
+		findNextName("page", ".bmp", &fname[0]);
+		SDL_SaveBMP(page, fname);
+	}
+}
+
+void CPrinter::fprintASCII85(FILE* f, Bit16u b)
+{
+	if (b != 256)
+	{
+		if (b < 256)
+			ASCII85Buffer[ASCII85BufferPos++] = (Bit8u)b;
+
+		if (ASCII85BufferPos == 4 || b == 257)
+		{
+			Bit32u num = (Bit32u)ASCII85Buffer[0] << 24 | (Bit32u)ASCII85Buffer[1] << 16 | (Bit32u)ASCII85Buffer[2] << 8 | (Bit32u)ASCII85Buffer[3];
+
+			// Deal with special case
+			if (num == 0 && b != 257)
+			{
+				fprintf(f, "z");
+				if (++ASCII85CurCol >= 79)
+				{
+					ASCII85CurCol = 0;
+					fprintf(f, "\n");
+				}
+			}
+			else
+			{
+				char buffer[5];
+				for (Bit8s i=4; i>=0; i--)
+				{
+					buffer[i] = (Bit8u)((Bit32u)num % (Bit32u)85);
+					buffer[i] += 33;
+					num /= (Bit32u)85;
+				}
+
+				// Make sure a line never starts with a % (which may be mistaken as start of a comment)
+				if (ASCII85CurCol == 0 && buffer[0] == '%')
+					fprintf(f, " ");
+				
+				for (int i=0; i<((b != 257)?5:ASCII85BufferPos+1); i++)
+				{
+					fprintf(f, "%c", buffer[i]);
+					if (++ASCII85CurCol >= 79)
+					{
+						ASCII85CurCol = 0;
+						fprintf(f, "\n");
+					}
+				}
+			}
+
+			ASCII85BufferPos = 0;
+		}
+
+	}
+	else // Close string
+	{
+		// Partial tupel if there are still bytes in the buffer
+		if (ASCII85BufferPos > 0)
+		{
+			for (Bit8u i = ASCII85BufferPos; i < 4; i++)
+				ASCII85Buffer[i] = 0;
+
+			fprintASCII85(f, 257);
+		}
+
+		fprintf(f, "~");
+		fprintf(f, ">\n");
+	}
+}
+
+void CPrinter::finishMultipage()
+{
+	if (outputHandle != NULL)
+	{
+		if (strcasecmp(output, "ps") == 0)
+		{
+			FILE* psfile = (FILE*)outputHandle;
+			fprintf(psfile, "%%%%Pages: %i\n", multiPageCounter);
+			fprintf(psfile, "%%%%EOF\n");
+			fclose(psfile);
+		}
+		else if (strcasecmp(output, "printer") == 0)
+		{
+#if defined (WIN32)
+			EndDoc(printerDC);
+#endif
+		}
+		outputHandle = NULL;
+	}
+}
+
+bool CPrinter::isBlank() {
+	bool blank = true;
+
+	SDL_LockSurface(page);
+
+	for (Bit16u y=0; y<page->h; y++)
+		for (Bit16u x=0; x<page->w; x++)
+			if (*((Bit8u*)page->pixels + x + (y*page->pitch)) != 0)
+				blank = false;
+
+	SDL_UnlockSurface(page);
+	return blank;
+}
+
+Bit8u CPrinter::getPixel(Bit32u num) {
+	// Respect the pitch
+	return *((Bit8u*)page->pixels + (num % page->w) + ((num / page->w) * page->pitch));
+}
+
+static Bit8u dataregister; // contents of the parallel port data register
+
+Bitu PRINTER_readdata(Bitu port,Bitu iolen) {
+	return dataregister;
+}
+
+void PRINTER_writedata(Bitu port,Bitu val,Bitu iolen) {
+	dataregister=val;
+}
+Bit8u controlreg = 0x04;
+
+Bitu PRINTER_readstatus(Bitu port,Bitu iolen) {
+	//LOG_MSG("PRINTER_readstatus CS:IP %8x:%8x",SegValue(cs),reg_eip);
+	// Don't create a CPrinter unless the program really wants to print
+	// Return standard: No error, printer online, no ack and not busy
+	if (!defaultPrinter)
+		return 0xDF;
+
+	// Printer is always online and never reports an error
+	Bit8u status =0x1f;// 0x18;
+
+//	if (controlreg&0x08==0)
+//		status |= 0x10;
+
+	if (!defaultPrinter->isBusy())
+		status |= 0x80;
+
+	if (!defaultPrinter->ack())
+		status |= 0x40;
+
+	return status;
+}
+
+static void FormFeed(bool pressed) {
+	if(pressed)
+		if (defaultPrinter) {
+			PIC_RemoveEvents(PRINTER_EventHandler);
+			if(printer_timout) timeout_dirty=false;
+			
+			defaultPrinter->formFeed();
+		}
+}
+
+
+static void PRINTER_EventHandler(Bitu param) {
+	//LOG_MSG("printerevent");
+	if(timeout_dirty) { // add another
+		PIC_AddEvent(PRINTER_EventHandler,(float)printer_timout,0);
+		//LOG_MSG("timeout renew");
+		timeout_dirty=false;
+	} else {
+		timeout_dirty=false;
+		FormFeed(true);
+	}
+}
+
+void PRINTER_writecontrol(Bitu port,Bitu val, Bitu iolen)
+{
+	//LOG_MSG("PRINTER_writecontrol CS:IP %8x:%8x",SegValue(cs),reg_eip);
+	// init printer if bit 4 is switched on
+	if ((val & 0x04) && defaultPrinter && (!(controlreg & 0x04)))
+		defaultPrinter->resetPrinterHard();
+
+	// data is strobed to the parallel printer on the falling edge of strobe bit
+	if(!(val&0x1) && (controlreg & 0x1)) {
+		if (!defaultPrinter)
+		defaultPrinter = new CPrinter(confdpi, confwidth,
+									confheight, confoutputDevice,
+									confmultipageOutput);
+		defaultPrinter->printChar(dataregister);
+		if(!timeout_dirty) {
+			PIC_AddEvent(PRINTER_EventHandler,(float)printer_timout,0);
+			timeout_dirty=true;
+		}
+	}
+
+	controlreg=val;
+	if (defaultPrinter)
+		defaultPrinter->setAutofeed((val & 0x02)>0);
+}
+
+Bitu PRINTER_readcontrol(Bitu port,Bitu iolen)
+{
+	//LOG_MSG("PRINTER_readcontrol CS:IP %8x:%8x",SegValue(cs),reg_eip);
+	// Don't create a CPrinter unless the program really wants to print
+	if (!defaultPrinter)
+		return 0xe0|controlreg;//0xe8;
+
+	return 0xe0|(defaultPrinter->getAutofeed()?0x02:0x00) | (controlreg&0xfd);
+}
+
+void PRINTER_Shutdown(Section* sec)
+{
+	if (defaultPrinter)
+	{
+		delete defaultPrinter;
+		defaultPrinter = NULL;
+	}
+}
+
+bool inited = false;
+bool PRINTER_isInited() {
+	return inited;
+}
+
+void PRINTER_Init(Section* sec) 
+{
+	Section_prop * section=static_cast<Section_prop *>(sec);
+	section->AddDestroyFunction(&PRINTER_Shutdown);
+
+	// Set base address of LPT1 in the BIOS variable segment
+	//real_writew(0x0040, 0x0008, LPTPORT);
+
+	if(!section->Get_bool("printer"))
+		return;
+	inited = true;
+	document_path = section->Get_string("docpath");
+	//font_path = section->Get_string("fontpath");
+	confdpi = section->Get_int("dpi");
+	confwidth = section->Get_int("width");
+	confheight = section->Get_int("height");
+	printer_timout = section->Get_int("timeout");
+	if(!printer_timout) timeout_dirty = true; // this will lock up the timeout
+	else timeout_dirty = false;
+	strcpy(&confoutputDevice[0], section->Get_string("printoutput"));
+	confmultipageOutput = section->Get_bool("multipage");
+
+	//IO_RegisterWriteHandler(LPTPORT,PRINTER_writedata,IO_MB);
+	//IO_RegisterReadHandler(LPTPORT,PRINTER_readdata,IO_MB);
+	
+	//IO_RegisterReadHandler(LPTPORT+1,PRINTER_readstatus,IO_MB);
+	//IO_RegisterWriteHandler(LPTPORT+2,PRINTER_writecontrol,IO_MB);
+	//IO_RegisterReadHandler(LPTPORT+2,PRINTER_readcontrol,IO_MB);
+
+	MAPPER_AddHandler(FormFeed,MK_f2,MMOD1,"ejectpage","formfeed");
+}
+
+#endif
diff --git a/src/hardware/parport/printer.h b/src/hardware/parport/printer.h
new file mode 100644
index 0000000..7d742c5
--- /dev/null
+++ b/src/hardware/parport/printer.h
@@ -0,0 +1,245 @@
+/*
+ *  Copyright (C) 2002-2004  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+//#include <dosbox.h>
+#include "config.h"
+
+#if C_PRINTER
+
+#if !defined __PRINTER_H
+#define __PRINTER_H
+
+#ifdef C_LIBPNG
+#include <png.h>
+#endif
+
+#include "SDL.h"
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#if defined (WIN32)
+#include <windows.h>
+#include <winspool.h>
+#endif
+
+#define STYLE_PROP 0x01
+#define STYLE_CONDENSED 0x02
+#define STYLE_BOLD 0x04
+#define STYLE_DOUBLESTRIKE 0x08
+#define STYLE_DOUBLEWIDTH 0x10
+#define STYLE_ITALICS 0x20
+#define STYLE_UNDERLINE 0x40
+#define STYLE_SUPERSCRIPT 0x80
+#define STYLE_SUBSCRIPT 0x100
+#define STYLE_STRIKETHROUGH 0x200
+#define STYLE_OVERSCORE 0x400
+#define STYLE_DOUBLEWIDTHONELINE 0x800
+#define STYLE_DOUBLEHEIGHT 0x1000
+
+#define SCORE_NONE 0x00
+#define SCORE_SINGLE 0x01
+#define SCORE_DOUBLE 0x02
+#define SCORE_SINGLEBROKEN 0x05
+#define SCORE_DOUBLEBROKEN 0x06
+
+#define QUALITY_DRAFT 0x01
+#define QUALITY_LQ 0x02
+
+#define COLOR_BLACK 7<<5
+
+enum Typeface
+{
+	roman = 0,
+	sansserif,
+	courier,
+	prestige,
+	script,
+	ocrb,
+	ocra,
+	orator,
+	orators,
+	scriptc,
+	romant,
+	sansserifh,
+	svbusaba = 30,
+	svjittra = 31
+};
+
+class CPrinter {
+public:
+
+	CPrinter (Bit16u dpi, Bit16u width, Bit16u height, char* output, bool multipageOutput);
+	virtual ~CPrinter();
+
+	// Process one character sent to virtual printer
+	void printChar(Bit8u ch);
+
+	// Hard Reset (like switching printer off and on)
+	void resetPrinterHard();
+
+	// Set Autofeed value 
+	void setAutofeed(bool feed);
+
+	// Get Autofeed value
+	bool getAutofeed();
+
+	// True if printer is unable to process more data right now (do not use printChar)
+	bool isBusy();
+
+	// True if the last sent character was received 
+	bool ack();
+
+	// Manual formfeed
+	void formFeed();
+
+	// Returns true if the current page is blank
+	bool isBlank();
+
+private:
+
+	// used to fill the color "sub-pallettes"
+	void FillPalette(Bit8u redmax, Bit8u greenmax, Bit8u bluemax, Bit8u colorID,
+							SDL_Palette* pal);
+
+    // Checks if given char belongs to a command and process it. If false, the character
+	// should be printed
+	bool processCommandChar(Bit8u ch);
+
+	// Resets the printer to the factory settings
+	void resetPrinter();
+
+	// Reload font. Must be called after changing dpi, style or cpi
+	void updateFont();
+
+	// Clears page. If save is true, saves the current page to a bitmap
+	void newPage(bool save, bool resetx);
+
+	// Blits the given glyph on the page surface. If add is true, the values of bitmap are
+	// added to the values of the pixels in the page
+	void blitGlyph(FT_Bitmap bitmap, Bit16u destx, Bit16u desty, bool add);
+
+	// Draws an anti-aliased line from (fromx, y) to (tox, y). If broken is true, gaps are included
+	void drawLine(Bitu fromx, Bitu tox, Bitu y, bool broken);
+
+	// Setup the bitGraph structure
+	void setupBitImage(Bit8u dens, Bit16u numCols);
+
+	// Process a character that is part of bit image. Must be called iff bitGraph.remBytes > 0.
+	void printBitGraph(Bit8u ch);
+
+	// Copies the codepage mapping from the constant array to CurMap
+	void selectCodepage(Bit16u cp);
+
+	// Output current page 
+	void outputPage();
+
+	// Prints out a byte using ASCII85 encoding (only outputs something every four bytes). When b>255, closes the ASCII85 string
+	void fprintASCII85(FILE* f, Bit16u b);
+
+	// Closes a multipage document
+	void finishMultipage();
+
+	// Returns value of the num-th pixel (couting left-right, top-down) in a safe way
+	Bit8u getPixel(Bit32u num);
+
+	FT_Library FTlib;					// FreeType2 library used to render the characters
+
+	SDL_Surface* page;					// Surface representing the current page
+	FT_Face curFont;					// The font currently used to render characters
+	Bit8u color;
+
+	Real64 curX, curY;					// Position of the print head (in inch)
+
+	Bit16u dpi;							// dpi of the page
+	Bit16u ESCCmd;						// ESC-command that is currently processed
+	bool ESCSeen;						// True if last read character was an ESC (0x1B)
+	bool FSSeen;						// True if last read character was an FS (0x1C) (IBM commands)
+
+	Bit8u numParam, neededParam;		// Numbers of parameters already read/needed to process command
+
+	Bit8u params[20];					// Buffer for the read params
+	Bit16u style;						// Style of font (see STYLE_* constants)
+	Real64 cpi, actcpi;					// CPI value set by program and the actual one (taking in account font types)
+	Bit8u score;						// Score for lines (see SCORE_* constants)
+
+	Real64 topMargin, bottomMargin, rightMargin, leftMargin;	// Margins of the page (in inch)
+	Real64 pageWidth, pageHeight;								// Size of page (in inch)
+	Real64 defaultPageWidth, defaultPageHeight;					// Default size of page (in inch)
+	Real64 lineSpacing;											// Size of one line (in inch)
+
+	Real64 horiztabs[32];				// Stores the set horizontal tabs (in inch)
+	Bit8u numHorizTabs;					// Number of configured tabs
+
+	Real64 verttabs[16];				// Stores the set vertical tabs (in inch)
+	Bit8u numVertTabs;					// Number of configured tabs
+
+	Bit8u curCharTable;					// Currently used char table und charset
+	Bit8u printQuality;					// Print quality (see QUALITY_* constants)
+
+	Typeface LQtypeFace;				// Typeface used in LQ printing mode
+
+	Real64 extraIntraSpace;				// Extra space between two characters (set by program, in inch)
+
+	bool charRead;						// True if a character was read since the printer was last initialized
+	bool autoFeed;						// True if a LF should automatically added after a CR
+	bool printUpperContr;				// True if the upper command characters should be printed
+
+	struct bitGraphicParams				// Holds information about printing bit images
+	{
+		Bit16u horizDens, vertDens;		// Density of image to print (in dpi)
+		bool adjacent;					// Print adjacent pixels? (ignored)
+		Bit8u bytesColumn;				// Bytes per column
+		Bit16u remBytes;				// Bytes left to read before image is done
+		Bit8u column[6];				// Bytes of the current and last column
+		Bit8u readBytesColumn;			// Bytes read so far for the current column
+	} bitGraph;
+
+	Bit8u densk, densl, densy, densz;	// Image density modes used in ESC K/L/Y/Z commands
+
+	Bit16u curMap[256];					// Currently used ASCII => Unicode mapping
+	Bit16u charTables[4];				// Charactertables
+
+	Real64 definedUnit;					// Unit used by some ESC/P2 commands (negative => use default)
+
+	bool multipoint;					// If multipoint mode is enabled
+	Real64 multiPointSize;				// Point size of font in multipoint mode
+	Real64 multicpi;					// CPI used in multipoint mode
+
+	Real64 hmi;							// Horizontal motion index (in inch; overrides CPI settings)
+
+	Bit8u msb;							// MSB mode
+	Bit16u numPrintAsChar;				// Number of bytes to print as characters (even when normally control codes)
+
+#if defined (WIN32)
+	HDC printerDC;						// Win32 printer device
+#endif
+
+	char* output;						// Output method selected by user
+	void* outputHandle;					// If not null, additional pages will be appended to the given handle
+	bool multipageOutput;				// If true, all pages are combined to one file/print job etc. until the "eject page" button is pressed
+	Bit16u multiPageCounter;			// Current page (when printing multipages)
+
+	Bit8u ASCII85Buffer[4];				// Buffer used in ASCII85 encoding
+	Bit8u ASCII85BufferPos;				// Position in ASCII85 encode buffer
+	Bit8u ASCII85CurCol;				// Columns printed so far in the current lines
+};
+
+#endif
+
+#endif
diff --git a/src/hardware/parport/printer_charmaps.cpp b/src/hardware/parport/printer_charmaps.cpp
new file mode 100644
index 0000000..5f3bed9
--- /dev/null
+++ b/src/hardware/parport/printer_charmaps.cpp
@@ -0,0 +1,309 @@
+#include "support.h"
+#include "printer_charmaps.h"
+
+// Various ASCII codepage to unicode maps
+
+static const Bit16u cp437Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x00e0,0x00e5,0x00e7,0x00ea,0x00eb,0x00e8,0x00ef,0x00ee,0x00ec,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x00f4,0x00f6,0x00f2,0x00fb,0x00f9,0x00ff,0x00d6,0x00dc,0x00a2,0x00a3,0x00a5,0x20a7,0x0192,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x00aa,0x00ba,0x00bf,0x2310,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp737Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x0391,0x0392,0x0393,0x0394,0x0395,0x0396,0x0397,0x0398,0x0399,0x039a,0x039b,0x039c,0x039d,0x039e,0x039f,0x03a0,
+0x03a1,0x03a3,0x03a4,0x03a5,0x03a6,0x03a7,0x03a8,0x03a9,0x03b1,0x03b2,0x03b3,0x03b4,0x03b5,0x03b6,0x03b7,0x03b8,
+0x03b9,0x03ba,0x03bb,0x03bc,0x03bd,0x03be,0x03bf,0x03c0,0x03c1,0x03c3,0x03c2,0x03c4,0x03c5,0x03c6,0x03c7,0x03c8,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03c9,0x03ac,0x03ad,0x03ae,0x03ca,0x03af,0x03cc,0x03cd,0x03cb,0x03ce,0x0386,0x0388,0x0389,0x038a,0x038c,0x038e,
+0x038f,0x00b1,0x2265,0x2264,0x03aa,0x03ab,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp775Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x0106,0x00fc,0x00e9,0x0101,0x00e4,0x0123,0x00e5,0x0107,0x0142,0x0113,0x0156,0x0157,0x012b,0x0179,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x014d,0x00f6,0x0122,0x00a2,0x015a,0x015b,0x00d6,0x00dc,0x00f8,0x00a3,0x00d8,0x00d7,0x00a4,
+0x0100,0x012a,0x00f3,0x017b,0x017c,0x017a,0x201d,0x00a6,0x00a9,0x00ae,0x00ac,0x00bd,0x00bc,0x0141,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x0104,0x010c,0x0118,0x0116,0x2563,0x2551,0x2557,0x255d,0x012e,0x0160,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x0172,0x016a,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x017d,
+0x0105,0x010d,0x0119,0x0117,0x012f,0x0161,0x0173,0x016b,0x017e,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x00d3,0x00df,0x014c,0x0143,0x00f5,0x00d5,0x00b5,0x0144,0x0136,0x0137,0x013b,0x013c,0x0146,0x0112,0x0145,0x2019,
+0x00ad,0x00b1,0x201c,0x00be,0x00b6,0x00a7,0x00f7,0x201e,0x00b0,0x2219,0x00b7,0x00b9,0x00b3,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp850Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x00e0,0x00e5,0x00e7,0x00ea,0x00eb,0x00e8,0x00ef,0x00ee,0x00ec,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x00f4,0x00f6,0x00f2,0x00fb,0x00f9,0x00ff,0x00d6,0x00dc,0x00f8,0x00a3,0x00d8,0x00d7,0x0192,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x00aa,0x00ba,0x00bf,0x00ae,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x00c1,0x00c2,0x00c0,0x00a9,0x2563,0x2551,0x2557,0x255d,0x00a2,0x00a5,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x00e3,0x00c3,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x00a4,
+0x00f0,0x00d0,0x00ca,0x00cb,0x00c8,0x0131,0x00cd,0x00ce,0x00cf,0x2518,0x250c,0x2588,0x2584,0x00a6,0x00cc,0x2580,
+0x00d3,0x00df,0x00d4,0x00d2,0x00f5,0x00d5,0x00b5,0x00fe,0x00de,0x00da,0x00db,0x00d9,0x00fd,0x00dd,0x00af,0x00b4,
+0x00ad,0x00b1,0x2017,0x00be,0x00b6,0x00a7,0x00f7,0x00b8,0x00b0,0x00a8,0x00b7,0x00b9,0x00b3,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp852Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x016f,0x0107,0x00e7,0x0142,0x00eb,0x0150,0x0151,0x00ee,0x0179,0x00c4,0x0106,
+0x00c9,0x0139,0x013a,0x00f4,0x00f6,0x013d,0x013e,0x015a,0x015b,0x00d6,0x00dc,0x0164,0x0165,0x0141,0x00d7,0x010d,
+0x00e1,0x00ed,0x00f3,0x00fa,0x0104,0x0105,0x017d,0x017e,0x0118,0x0119,0x00ac,0x017a,0x010c,0x015f,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x00c1,0x00c2,0x011a,0x015e,0x2563,0x2551,0x2557,0x255d,0x017b,0x017c,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x0102,0x0103,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x00a4,
+0x0111,0x0110,0x010e,0x00cb,0x010f,0x0147,0x00cd,0x00ce,0x011b,0x2518,0x250c,0x2588,0x2584,0x0162,0x016e,0x2580,
+0x00d3,0x00df,0x00d4,0x0143,0x0144,0x0148,0x0160,0x0161,0x0154,0x00da,0x0155,0x0170,0x00fd,0x00dd,0x0163,0x00b4,
+0x00ad,0x02dd,0x02db,0x02c7,0x02d8,0x00a7,0x00f7,0x00b8,0x00b0,0x00a8,0x02d9,0x0171,0x0158,0x0159,0x25a0,0x00a0
+};
+
+static const Bit16u cp855Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x0452,0x0402,0x0453,0x0403,0x0451,0x0401,0x0454,0x0404,0x0455,0x0405,0x0456,0x0406,0x0457,0x0407,0x0458,0x0408,
+0x0459,0x0409,0x045a,0x040a,0x045b,0x040b,0x045c,0x040c,0x045e,0x040e,0x045f,0x040f,0x044e,0x042e,0x044a,0x042a,
+0x0430,0x0410,0x0431,0x0411,0x0446,0x0426,0x0434,0x0414,0x0435,0x0415,0x0444,0x0424,0x0433,0x0413,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x0445,0x0425,0x0438,0x0418,0x2563,0x2551,0x2557,0x255d,0x0439,0x0419,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x043a,0x041a,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x00a4,
+0x043b,0x041b,0x043c,0x041c,0x043d,0x041d,0x043e,0x041e,0x043f,0x2518,0x250c,0x2588,0x2584,0x041f,0x044f,0x2580,
+0x042f,0x0440,0x0420,0x0441,0x0421,0x0442,0x0422,0x0443,0x0423,0x0436,0x0416,0x0432,0x0412,0x044c,0x042c,0x2116,
+0x00ad,0x044b,0x042b,0x0437,0x0417,0x0448,0x0428,0x044d,0x042d,0x0449,0x0429,0x0447,0x0427,0x00a7,0x25a0,0x00a0
+};
+
+static const Bit16u cp857Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x00e0,0x00e5,0x00e7,0x00ea,0x00eb,0x00e8,0x00ef,0x00ee,0x0131,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x00f4,0x00f6,0x00f2,0x00fb,0x00f9,0x0130,0x00d6,0x00dc,0x00f8,0x00a3,0x00d8,0x015e,0x015f,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x011e,0x011f,0x00bf,0x00ae,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x00c1,0x00c2,0x00c0,0x00a9,0x2563,0x2551,0x2557,0x255d,0x00a2,0x00a5,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x00e3,0x00c3,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x00a4,
+0x00ba,0x00aa,0x00ca,0x00cb,0x00c8,0x0000,0x00cd,0x00ce,0x00cf,0x2518,0x250c,0x2588,0x2584,0x00a6,0x00cc,0x2580,
+0x00d3,0x00df,0x00d4,0x00d2,0x00f5,0x00d5,0x00b5,0x0000,0x00d7,0x00da,0x00db,0x00d9,0x00ec,0x00ff,0x00af,0x00b4,
+0x00ad,0x00b1,0x0000,0x00be,0x00b6,0x00a7,0x00f7,0x00b8,0x00b0,0x00a8,0x00b7,0x00b9,0x00b3,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp860Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e3,0x00e0,0x00c1,0x00e7,0x00ea,0x00ca,0x00e8,0x00cd,0x00d4,0x00ec,0x00c3,0x00c2,
+0x00c9,0x00c0,0x00c8,0x00f4,0x00f5,0x00f2,0x00da,0x00f9,0x00cc,0x00d5,0x00dc,0x00a2,0x00a3,0x00d9,0x20a7,0x00d3,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x00aa,0x00ba,0x00bf,0x00d2,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp861Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x00e0,0x00e5,0x00e7,0x00ea,0x00eb,0x00e8,0x00d0,0x00f0,0x00de,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x00f4,0x00f6,0x00fe,0x00fb,0x00dd,0x00fd,0x00d6,0x00dc,0x00f8,0x00a3,0x00d8,0x20a7,0x0192,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00c1,0x00cd,0x00d3,0x00da,0x00bf,0x2310,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp862Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x05d0,0x05d1,0x05d2,0x05d3,0x05d4,0x05d5,0x05d6,0x05d7,0x05d8,0x05d9,0x05da,0x05db,0x05dc,0x05dd,0x05de,0x05df,
+0x05e0,0x05e1,0x05e2,0x05e3,0x05e4,0x05e5,0x05e6,0x05e7,0x05e8,0x05e9,0x05ea,0x00a2,0x00a3,0x00a5,0x20a7,0x0192,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x00aa,0x00ba,0x00bf,0x2310,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp863Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00c2,0x00e0,0x00b6,0x00e7,0x00ea,0x00eb,0x00e8,0x00ef,0x00ee,0x2017,0x00c0,0x00a7,
+0x00c9,0x00c8,0x00ca,0x00f4,0x00cb,0x00cf,0x00fb,0x00f9,0x00a4,0x00d4,0x00dc,0x00a2,0x00a3,0x00d9,0x00db,0x0192,
+0x00a6,0x00b4,0x00f3,0x00fa,0x00a8,0x00b8,0x00b3,0x00af,0x00ce,0x2310,0x00ac,0x00bd,0x00bc,0x00be,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp864Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x066a,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00b0,0x00b7,0x2219,0x221a,0x2592,0x2500,0x2502,0x253c,0x2524,0x252c,0x251c,0x2534,0x2510,0x250c,0x2514,0x2518,
+0x03b2,0x221e,0x03c6,0x00b1,0x00bd,0x00bc,0x2248,0x00ab,0x00bb,0xfef7,0xfef8,0x0000,0x0000,0xfefb,0xfefc,0x0000,
+0x00a0,0x00ad,0xfe82,0x00a3,0x00a4,0xfe84,0x0000,0x0000,0xfe8e,0xfe8f,0xfe95,0xfe99,0x060c,0xfe9d,0xfea1,0xfea5,
+0x0660,0x0661,0x0662,0x0663,0x0664,0x0665,0x0666,0x0667,0x0668,0x0669,0xfed1,0x061b,0xfeb1,0xfeb5,0xfeb9,0x061f,
+0x00a2,0xfe80,0xfe81,0xfe83,0xfe85,0xfeca,0xfe8b,0xfe8d,0xfe91,0xfe93,0xfe97,0xfe9b,0xfe9f,0xfea3,0xfea7,0xfea9,
+0xfeab,0xfead,0xfeaf,0xfeb3,0xfeb7,0xfebb,0xfebf,0xfec1,0xfec5,0xfecb,0xfecf,0x00a6,0x00ac,0x00f7,0x00d7,0xfec9,
+0x0640,0xfed3,0xfed7,0xfedb,0xfedf,0xfee3,0xfee7,0xfeeb,0xfeed,0xfeef,0xfef3,0xfebd,0xfecc,0xfece,0xfecd,0xfee1,
+0xfe7d,0x0651,0xfee5,0xfee9,0xfeec,0xfef0,0xfef2,0xfed0,0xfed5,0xfef5,0xfef6,0xfedd,0xfed9,0xfef1,0x25a0,
+};
+
+static const Bit16u cp865Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x00e0,0x00e5,0x00e7,0x00ea,0x00eb,0x00e8,0x00ef,0x00ee,0x00ec,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x00f4,0x00f6,0x00f2,0x00fb,0x00f9,0x00ff,0x00d6,0x00dc,0x00f8,0x00a3,0x00d8,0x20a7,0x0192,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x00aa,0x00ba,0x00bf,0x2310,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00a4,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp866Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,0x0418,0x0419,0x041a,0x041b,0x041c,0x041d,0x041e,0x041f,
+0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,0x0428,0x0429,0x042a,0x042b,0x042c,0x042d,0x042e,0x042f,
+0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,0x0438,0x0439,0x043a,0x043b,0x043c,0x043d,0x043e,0x043f,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,0x0448,0x0449,0x044a,0x044b,0x044c,0x044d,0x044e,0x044f,
+0x0401,0x0451,0x0404,0x0454,0x0407,0x0457,0x040e,0x045e,0x00b0,0x2219,0x00b7,0x221a,0x2116,0x00a4,0x25a0,0x00a0
+};
+
+const CHARMAP charmap[] = {
+	{437, cp437Map},
+	{737, cp737Map},
+	{775, cp775Map},
+	{850, cp850Map},
+	{852, cp852Map},
+	{855, cp855Map},
+	{857, cp857Map},
+	{860, cp860Map},
+	{861, cp861Map},
+	{863, cp863Map},
+	{864, cp864Map},
+	{865, cp865Map},
+	{866, cp866Map},
+	{0, NULL},
+};
+
+const Bit16u codepages[15] = {0, 437, 932, 850, 851, 853, 855, 860, 863, 865, 852, 857, 862, 864, 866};
+
+// TODO: Implement all international charsets
+const Bit16u intCharSets[15][12] =
+{
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e}, // USA
+	{0x0023, 0x0024, 0x00e0, 0x00ba, 0x00e7, 0x00a7, 0x005e, 0x0060, 0x00e9, 0x00f9, 0x00e8, 0x00a8}, // France
+	{0x0023, 0x0024, 0x00a7, 0x00c4, 0x00d6, 0x00dc, 0x005e, 0x0060, 0x00e4, 0x00f6, 0x00fc, 0x00df}, // Germany
+	{0x00a3, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e}, // UK
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x00a7, 0x00c4, 0x0027, 0x0022, 0x00b6, 0x0060, 0x00a9, 0x00ae, 0x2020, 0x2122} // Legal
+};
diff --git a/src/hardware/parport/printer_charmaps.h b/src/hardware/parport/printer_charmaps.h
new file mode 100644
index 0000000..4370bb0
--- /dev/null
+++ b/src/hardware/parport/printer_charmaps.h
@@ -0,0 +1,26 @@
+/*
+ *  Copyright (C) 2002-2004  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+typedef struct {
+	Bitu codepage;
+	const Bit16u* map;
+} CHARMAP;
+
+extern const CHARMAP charmap[];
+extern const Bit16u codepages[15];
+extern const Bit16u intCharSets[15][12];
diff --git a/src/hardware/parport/printer_if.h b/src/hardware/parport/printer_if.h
new file mode 100644
index 0000000..f3272c5
--- /dev/null
+++ b/src/hardware/parport/printer_if.h
@@ -0,0 +1,11 @@
+
+#ifndef PRINTER_IF
+#define PRINTER_IF
+Bitu PRINTER_readdata(Bitu port,Bitu iolen);
+void PRINTER_writedata(Bitu port,Bitu val,Bitu iolen);
+Bitu PRINTER_readstatus(Bitu port,Bitu iolen);
+void PRINTER_writecontrol(Bitu port,Bitu val, Bitu iolen);
+Bitu PRINTER_readcontrol(Bitu port,Bitu iolen);
+
+bool PRINTER_isInited();
+#endif
diff --git a/src/hardware/parport/printer_redir.cpp b/src/hardware/parport/printer_redir.cpp
new file mode 100644
index 0000000..bd99091
--- /dev/null
+++ b/src/hardware/parport/printer_redir.cpp
@@ -0,0 +1,72 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include "dosbox.h"
+
+#if C_PRINTER
+
+#include "parport.h"
+//#include "callback.h"
+#include "printer_redir.h"
+
+// Purpose of this is to pass LPT register access to the virtual printer 
+
+CPrinterRedir::CPrinterRedir(Bitu nr, Bit8u initIrq, CommandLine* cmd)
+                              :CParallel (cmd, nr, initIrq) {
+	InstallationSuccessful = PRINTER_isInited();
+}
+
+CPrinterRedir::~CPrinterRedir () {
+	// close file
+}
+
+bool CPrinterRedir::Putchar(Bit8u val)
+{	
+	Write_CON(0xD4);
+	// strobe data out
+	Write_PR(val);
+	Write_CON(0xD5); // strobe pulse
+	Write_CON(0xD4); // strobe off
+	Read_SR();		 // clear ack
+
+#if PARALLEL_DEBUG
+	log_par(dbg_putchar,"putchar  0x%2x",val);
+	if(dbg_plainputchar) fprintf(debugfp,"%c",val);
+#endif
+
+	return true;
+}
+Bitu CPrinterRedir::Read_PR() {
+	return PRINTER_readdata(0,1);
+}
+Bitu CPrinterRedir::Read_COM() {
+	return PRINTER_readcontrol(0,1);
+}
+Bitu CPrinterRedir::Read_SR() {
+	return PRINTER_readstatus(0,1);
+}
+void CPrinterRedir::Write_PR(Bitu val) {
+	PRINTER_writedata(0,val,1);
+}
+void CPrinterRedir::Write_CON(Bitu val) {
+	PRINTER_writecontrol(0,val,1);
+}
+void CPrinterRedir::Write_IOSEL(Bitu val) {
+	// nothing
+}
+void CPrinterRedir::handleUpperEvent(Bit16u type) {}
+#endif // C_PRINTER
diff --git a/src/hardware/parport/printer_redir.h b/src/hardware/parport/printer_redir.h
new file mode 100644
index 0000000..005b439
--- /dev/null
+++ b/src/hardware/parport/printer_redir.h
@@ -0,0 +1,31 @@
+
+// include guard
+#ifndef DOSBOX_PRREDIR_H
+#define DOSBOX_PRREDIR_H
+
+#include "dosbox.h"
+#include "parport.h"
+#include "printer_if.h"
+
+class CPrinterRedir : public CParallel {
+public:
+	CPrinterRedir(Bitu nr, Bit8u initIrq, CommandLine* cmd);
+	
+
+	~CPrinterRedir();
+	
+	bool InstallationSuccessful;	// check after constructing. If
+									// something was wrong, delete it right away.
+	Bitu Read_PR();
+	Bitu Read_COM();
+	Bitu Read_SR();
+
+	void Write_PR(Bitu);
+	void Write_CON(Bitu);
+	void Write_IOSEL(Bitu);
+	bool Putchar(Bit8u);
+
+	void handleUpperEvent(Bit16u type);
+};
+
+#endif	// include guard
diff --git a/src/hardware/serialport/Makefile.in b/src/hardware/serialport/Makefile.in
index ee714d3..957424a 100644
--- a/src/hardware/serialport/Makefile.in
+++ b/src/hardware/serialport/Makefile.in
@@ -206,6 +206,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/hardware/serialport/directserial.cpp b/src/hardware/serialport/directserial.cpp
index 529c11b..af48a2f 100644
--- a/src/hardware/serialport/directserial.cpp
+++ b/src/hardware/serialport/directserial.cpp
@@ -96,6 +96,26 @@ CDirectSerial::~CDirectSerial () {
 // to be continued...
 
 void CDirectSerial::handleUpperEvent(Bit16u type) {
+/*
+#if SERIAL_DEBUG
+		const char* s;
+		const char* s2;
+		switch(type) {
+		case SERIAL_POLLING_EVENT: s = "POLLING_EVENT"; break;
+		case SERIAL_RX_EVENT: s = "RX_EVENT"; break;
+		case SERIAL_TX_EVENT: s = "TX_EVENT"; break;
+		case SERIAL_THR_EVENT: s = "THR_EVENT"; break;
+		}
+		switch(rx_state) {
+		case D_RX_IDLE: s2 = "RX_IDLE"; break;
+		case D_RX_WAIT: s2 = "RX_WAIT"; break;
+		case D_RX_BLOCKED: s2 = "RX_BLOCKED"; break;
+		case D_RX_FASTWAIT: s2 = "RX_FASTWAIT"; break;
+		}
+		log_ser(dbg_aux,"Directserial: Event enter %s, %s",s,s2);
+#endif
+		*/
+
 	switch(type) {
 		case SERIAL_POLLING_EVENT: {
 			setEvent(SERIAL_POLLING_EVENT, 1.0f);
@@ -232,6 +252,22 @@ void CDirectSerial::handleUpperEvent(Bit16u type) {
 			break;				   
 		}
 	}
+	/*
+	#if SERIAL_DEBUG
+		switch(type) {
+		case SERIAL_POLLING_EVENT: s = "POLLING_EVENT"; break;
+		case SERIAL_RX_EVENT: s = "RX_EVENT"; break;
+		case SERIAL_TX_EVENT: s = "TX_EVENT"; break;
+		case SERIAL_THR_EVENT: s = "THR_EVENT"; break;
+		}
+		switch(rx_state) {
+			case D_RX_IDLE: s2 = "RX_IDLE"; break;
+			case D_RX_WAIT: s2 = "RX_WAIT"; break;
+			case D_RX_BLOCKED: s2 = "RX_BLOCKED"; break;
+			case D_RX_FASTWAIT: s2 = "RX_FASTWAIT"; break;
+		}
+		log_ser(dbg_aux,"Directserial: Event exit %s, %s",s,s2);
+#endif*/
 }
 
 bool CDirectSerial::doReceive() {
diff --git a/src/ints/Makefile.in b/src/ints/Makefile.in
index 7b3c934..242e331 100644
--- a/src/ints/Makefile.in
+++ b/src/ints/Makefile.in
@@ -210,6 +210,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/ints/bios.cpp b/src/ints/bios.cpp
index a61bfe5..209913b 100644
--- a/src/ints/bios.cpp
+++ b/src/ints/bios.cpp
@@ -31,6 +31,7 @@
 #include "mouse.h"
 #include "setup.h"
 #include "serialport.h"
+#include "parport.h"
 
 
 /* if mem_systems 0 then size_extended is reported as the real size else 
@@ -1042,11 +1043,6 @@ public:
 		//Bit16u config=0x4400;	//1 Floppy, 2 serial and 1 parallel 
 		Bit16u config = 0x0;
 		
-		// set number of parallel ports
-		// if(ppindex == 0) config |= 0x8000; // looks like 0 ports are not specified
-		//else if(ppindex == 1) config |= 0x0000;
-		if(ppindex == 2) config |= 0x4000;
-		else config |= 0xc000;	// 3 ports
 #if (C_FPU)
 		//FPU
 		config|=0x2;
@@ -1128,6 +1124,33 @@ void BIOS_SetComPorts(Bit16u baseaddr[]) {
 	CMOS_SetRegister(0x14,(Bit8u)(equipmentword&0xff)); //Should be updated on changes
 }
 
+void BIOS_SetLPTPort(Bitu port, Bit16u baseaddr) {
+	switch(port) {
+	case 0:
+		mem_writew(BIOS_ADDRESS_LPT1,baseaddr);
+		mem_writeb(BIOS_LPT1_TIMEOUT, 10);
+		break;
+	case 1:
+		mem_writew(BIOS_ADDRESS_LPT2,baseaddr);
+		mem_writeb(BIOS_LPT2_TIMEOUT, 10);
+		break;
+	case 2:
+		mem_writew(BIOS_ADDRESS_LPT3,baseaddr);
+		mem_writeb(BIOS_LPT3_TIMEOUT, 10);
+		break;
+	}
+
+	// set equipment word: count ports
+	Bit16u portcount=0;
+	if(mem_readw(BIOS_ADDRESS_LPT1) != 0) portcount++;
+	if(mem_readw(BIOS_ADDRESS_LPT2) != 0) portcount++;
+	if(mem_readw(BIOS_ADDRESS_LPT3) != 0) portcount++;
+	
+	Bit16u equipmentword = mem_readw(BIOS_CONFIGURATION);
+	equipmentword &= (~0xC000);
+	equipmentword |= (portcount << 14);
+	mem_writew(BIOS_CONFIGURATION,equipmentword);
+}
 
 static BIOS* test;
 
diff --git a/src/libs/Makefile.am b/src/libs/Makefile.am
index 303bc37..4b227a7 100644
--- a/src/libs/Makefile.am
+++ b/src/libs/Makefile.am
@@ -1,3 +1,4 @@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 
-SUBDIRS = zmbv gui_tk
+SUBDIRS = zmbv gui_tk porttalk
+
diff --git a/src/libs/Makefile.in b/src/libs/Makefile.in
index 5b5a8e3..5fe87eb 100644
--- a/src/libs/Makefile.in
+++ b/src/libs/Makefile.in
@@ -205,6 +205,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -288,7 +289,7 @@ top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
-SUBDIRS = zmbv gui_tk
+SUBDIRS = zmbv gui_tk porttalk
 all: all-recursive
 
 .SUFFIXES:
diff --git a/src/libs/gui_tk/Makefile.in b/src/libs/gui_tk/Makefile.in
index 50f8e48..dc1ff41 100644
--- a/src/libs/gui_tk/Makefile.in
+++ b/src/libs/gui_tk/Makefile.in
@@ -204,6 +204,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/libs/porttalk/Makefile.am b/src/libs/porttalk/Makefile.am
new file mode 100644
index 0000000..c7f50aa
--- /dev/null
+++ b/src/libs/porttalk/Makefile.am
@@ -0,0 +1,4 @@
+AM_CPPFLAGS = -I$(top_srcdir)/include
+
+noinst_LIBRARIES = libporttalk.a
+libporttalk_a_SOURCES = porttalk.cpp porttalk.h porttalk_IOCTL.h
diff --git a/src/libs/porttalk/Makefile.in b/src/libs/porttalk/Makefile.in
new file mode 100644
index 0000000..a7cce77
--- /dev/null
+++ b/src/libs/porttalk/Makefile.in
@@ -0,0 +1,562 @@
+# Makefile.in generated by automake 1.15 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2014 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/libs/porttalk
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
+libporttalk_a_AR = $(AR) $(ARFLAGS)
+libporttalk_a_LIBADD =
+am_libporttalk_a_OBJECTS = porttalk.$(OBJEXT)
+libporttalk_a_OBJECTS = $(am_libporttalk_a_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+AM_V_CXX = $(am__v_CXX_@AM_V@)
+am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
+am__v_CXX_0 = @echo "  CXX     " $@;
+am__v_CXX_1 = 
+CXXLD = $(CXX)
+CXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \
+	-o $@
+AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
+am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
+am__v_CXXLD_0 = @echo "  CXXLD   " $@;
+am__v_CXXLD_1 = 
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = $(libporttalk_a_SOURCES)
+DIST_SOURCES = $(libporttalk_a_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/depcomp
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ALSA_CFLAGS = @ALSA_CFLAGS@
+ALSA_LIBS = @ALSA_LIBS@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SDL_CFLAGS = @SDL_CFLAGS@
+SDL_CONFIG = @SDL_CONFIG@
+SDL_LIBS = @SDL_LIBS@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+WINDRES = @WINDRES@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+runstatedir = @runstatedir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AM_CPPFLAGS = -I$(top_srcdir)/include
+noinst_LIBRARIES = libporttalk.a
+libporttalk_a_SOURCES = porttalk.cpp porttalk.h porttalk_IOCTL.h
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cpp .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu src/libs/porttalk/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu src/libs/porttalk/Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+
+libporttalk.a: $(libporttalk_a_OBJECTS) $(libporttalk_a_DEPENDENCIES) $(EXTRA_libporttalk_a_DEPENDENCIES) 
+	$(AM_V_at)-rm -f libporttalk.a
+	$(AM_V_AR)$(libporttalk_a_AR) libporttalk.a $(libporttalk_a_OBJECTS) $(libporttalk_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libporttalk.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/porttalk.Po@am__quote@
+
+.cpp.o:
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<
+
+.cpp.obj:
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES cscopelist-am ctags ctags-am distclean \
+	distclean-compile distclean-generic distclean-tags distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
+
+.PRECIOUS: Makefile
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/libs/porttalk/PortTalk_IOCTL.h b/src/libs/porttalk/PortTalk_IOCTL.h
new file mode 100644
index 0000000..5cc41a6
--- /dev/null
+++ b/src/libs/porttalk/PortTalk_IOCTL.h
@@ -0,0 +1,37 @@
+/******************************************************************************/
+/*                                                                            */
+/*                    PortTalk Driver for Windows NT/2000/XP                  */
+/*                        Version 2.0, 12th January 2002                      */
+/*                          http://www.beyondlogic.org                        */
+/*                                                                            */
+/* Copyright  2002 Craig Peacock. Craig.Peacock@beyondlogic.org              */
+/* Any publication or distribution of this code in source form is prohibited  */
+/* without prior written permission of the copyright holder. This source code */
+/* is provided "as is", without any guarantee made as to its suitability or   */
+/* fitness for any particular use. Permission is herby granted to modify or   */
+/* enhance this sample code to produce a derivative program which may only be */
+/* distributed in compiled object form only.                                  */
+/******************************************************************************/
+
+#define PORTTALK_TYPE 40000 /* 32768-65535 are reserved for customers */
+
+// The IOCTL function codes from 0x800 to 0xFFF are for customer use.
+
+#define IOCTL_IOPM_RESTRICT_ALL_ACCESS \
+    CTL_CODE(PORTTALK_TYPE, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_IOPM_ALLOW_EXCUSIVE_ACCESS \
+    CTL_CODE(PORTTALK_TYPE, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_SET_IOPM \
+    CTL_CODE(PORTTALK_TYPE, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_ENABLE_IOPM_ON_PROCESSID \
+    CTL_CODE(PORTTALK_TYPE, 0x903, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_READ_PORT_UCHAR \
+    CTL_CODE(PORTTALK_TYPE, 0x904, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_WRITE_PORT_UCHAR \
+    CTL_CODE(PORTTALK_TYPE, 0x905, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
diff --git a/src/libs/porttalk/porttalk.cpp b/src/libs/porttalk/porttalk.cpp
new file mode 100644
index 0000000..db9722b
--- /dev/null
+++ b/src/libs/porttalk/porttalk.cpp
@@ -0,0 +1,247 @@
+#include "config.h"
+#include "logging.h"
+
+#if defined (_MSC_VER) 
+void outportb(Bit32u portid, Bit8u value) {
+  __asm mov edx,portid
+  __asm mov al,value
+  __asm out dx,al
+}
+
+Bit8u inportb(Bit32u portid) {
+  Bit8u value;
+  
+  __asm mov edx,portid
+  __asm in al,dx
+  __asm mov value,al
+  return value;
+}
+
+void outportw(Bit32u portid, Bit16u value) {
+  __asm mov edx,portid
+  __asm mov ax,value
+  __asm out dx,ax
+}
+
+Bit16u inportw(Bit32u portid) {
+  Bit16u value;
+  
+  __asm mov edx,portid
+  __asm in ax,dx
+  __asm mov value,ax
+  return value;
+}
+
+void outportd(Bit32u portid, Bit32u value) {
+  __asm mov edx,portid
+  __asm mov eax,value
+  __asm out dx,eax
+}
+
+Bit32u inportd(Bit32u portid) {
+  Bit32u value;
+  
+  __asm mov edx,portid
+  __asm in eax,dx
+  __asm mov value,eax
+  return value;
+}
+
+#else
+void outportb(Bit32u portid, Bit8u value) {
+   __asm__ volatile (
+      "movl   %0,%%edx   \n"
+      "movb   %1,%%al      \n"
+      "outb   %%al,%%dx   "
+      :
+      :   "r" (portid), "r" (value)
+      :   "edx", "al"
+   );
+}
+Bit8u inportb(Bit32u portid) {
+   Bit8u value;
+   __asm__ volatile (
+      "movl   %1,%%edx   \n"
+      "inb   %%dx,%%al   \n"
+      "movb   %%al,%0      "
+      :   "=m" (value)
+      :   "r" (portid)
+      :   "edx", "al", "memory"
+   );
+  return value;
+}
+#endif
+
+#ifdef WIN32
+
+// WIN specific
+#include "sdl.h"
+#include <windows.h>
+#include <winioctl.h> // NEEDED by GCC
+#include "porttalk.h"
+#include <stdio.h>
+#include <process.h>
+
+// PortTalk_IOCTL.h can be downloaded with PortTalk
+#include "PortTalk_IOCTL.h"
+
+typedef struct driverpermstruct {
+	Bit16u offset;
+	Bit8u value;
+} permblock;
+
+static HANDLE porttalkhandle=INVALID_HANDLE_VALUE;
+static Bit8u ioperm[8192];
+static bool isNT = false;
+
+bool initPorttalk() {
+	// handles neded for starting service
+	SC_HANDLE  ServiceManager = NULL;
+	SC_HANDLE  PorttalkService = NULL;
+
+	// check which platform we are on
+	OSVERSIONINFO osvi;
+	memset(&osvi,0,sizeof(OSVERSIONINFO));
+	osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
+	if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) ) {
+		LOG_MSG("GET VERSION failed!");
+		return false;
+	}
+	if(osvi.dwPlatformId==2) isNT=true;
+	
+	if(isNT && porttalkhandle==INVALID_HANDLE_VALUE) {
+		porttalkhandle = CreateFile("\\\\.\\PortTalk", GENERIC_READ,
+				0, NULL,OPEN_EXISTING, FILE_ATTRIBUTE_DEVICE, NULL);
+
+		if (porttalkhandle == INVALID_HANDLE_VALUE) {
+			Bitu retval=0;
+			// Porttalk service is not started. Attempt to start it.
+			ServiceManager = OpenSCManager (NULL,	// NULL is local machine
+					NULL,							// default database
+					SC_MANAGER_ENUMERATE_SERVICE);	// desired access
+			
+			if(ServiceManager==NULL) {
+				// No rights to enumerate services
+				LOG_MSG("You do not have the rights to enumerate services.");
+				return false;
+			}
+			PorttalkService = OpenService(ServiceManager,
+                                  "PortTalk",		// service name
+                                  SERVICE_START);	// desired access
+			
+			if(PorttalkService==NULL) {
+				// get causes
+				switch (retval=GetLastError()) {
+                case ERROR_ACCESS_DENIED:
+					LOG_MSG("You do not have the rights to enumerate services.");
+					break;
+                case ERROR_SERVICE_DOES_NOT_EXIST:
+					LOG_MSG("Porttalk service is not installed.");
+					break;
+				default:
+					LOG_MSG("Error %d occured accessing porttalk dirver.",retval);
+					break;
+				}
+				goto error;
+			}
+
+			// start it
+			retval = StartService (PorttalkService,
+				0,             // number of arguments
+				NULL);         // pointer to arguments
+			if(!retval) {
+				// couldn't start it
+				if((retval=GetLastError())!=ERROR_SERVICE_ALREADY_RUNNING) {
+					LOG_MSG("Could not start Porttalk service. Error %d.",retval);
+					goto error;
+				}
+			}
+			CloseServiceHandle(PorttalkService);
+			CloseServiceHandle(ServiceManager);
+
+			// try again
+			porttalkhandle = CreateFile("\\\\.\\PortTalk", GENERIC_READ,
+				0, NULL,OPEN_EXISTING, FILE_ATTRIBUTE_DEVICE, NULL);
+			
+			if (porttalkhandle == INVALID_HANDLE_VALUE) {
+				// bullshit
+				LOG_MSG(
+					"Porttalk driver could not be opened after being started successully.");
+				return false;
+			}
+
+		}
+		for(int i = 0; i < sizeof(ioperm); i++) ioperm[i]=0xff;
+		int retval;
+
+		DeviceIoControl(	porttalkhandle,
+				IOCTL_IOPM_RESTRICT_ALL_ACCESS,
+				NULL,0,
+				NULL,0,
+				(LPDWORD)&retval,
+				NULL);
+	}
+	return true;
+error:
+	if(PorttalkService) CloseServiceHandle(PorttalkService);
+	if(ServiceManager) CloseServiceHandle(ServiceManager);
+	return false;
+}
+void addIOPermission(Bit16u port) {
+	if(isNT)
+		ioperm[(port>>3)]&=(~(1<<(port&0x7)));
+}
+
+bool setPermissionList() {
+	if(!isNT) return true;
+	if(porttalkhandle!=INVALID_HANDLE_VALUE) {
+		permblock b;
+		int pid = _getpid();
+		int reetval=0;
+		Bit32u retval=0;
+		//output permission list to driver
+		for(int i = 0; i < sizeof(ioperm);i++) {
+			b.offset=i;
+			b.value=ioperm[i];
+			
+			retval=DeviceIoControl(	porttalkhandle,
+							IOCTL_SET_IOPM,
+							(LPDWORD)&b,3,
+							NULL,0,
+							(LPDWORD)&reetval,
+							NULL);
+			if(retval==0) return false;
+		}
+		
+		
+		reetval=DeviceIoControl(	porttalkhandle,
+							IOCTL_ENABLE_IOPM_ON_PROCESSID,
+							(LPDWORD)&pid,4,
+							NULL,0,
+							(LPDWORD)&retval,
+							NULL);
+		SDL_Delay(100);
+		return reetval!=0;
+	}
+	else return false;
+}
+#endif
+
+#ifdef LINUX
+// This Linux ioperm only works up to port 0x3FF
+#include <sys/perm.h>
+
+bool initPorttalk() {
+	if(ioperm(0x3da,1,1) < 0) return false;
+	return true;
+}
+
+void addIOPermission(Bit16u port) {
+	ioperm(port,1,1);
+}
+
+bool setPermissionList() {
+	return true;
+}
+
+#endif
diff --git a/src/libs/porttalk/porttalk.h b/src/libs/porttalk/porttalk.h
new file mode 100644
index 0000000..a2fc06b
--- /dev/null
+++ b/src/libs/porttalk/porttalk.h
@@ -0,0 +1,19 @@
+#ifndef PORTTALK_H
+#define PORTTALK_H
+
+#include "config.h"
+
+bool initPorttalk(void);
+bool setPermissionList();
+void addIOPermission(Bit16u port);
+
+void outportb(Bit32u portid, Bit8u value);
+Bit8u inportb(Bit32u portid);
+
+void outportd(Bit32u portid, Bit32u value);
+Bit32u inportd(Bit32u portid);
+
+void outportw(Bit32u portid, Bit16u value);
+Bit16u inportw(Bit32u portid);
+
+#endif
diff --git a/src/libs/zmbv/Makefile.in b/src/libs/zmbv/Makefile.in
index 74b0eb7..7e6ffcf 100644
--- a/src/libs/zmbv/Makefile.in
+++ b/src/libs/zmbv/Makefile.in
@@ -145,6 +145,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/misc/Makefile.in b/src/misc/Makefile.in
index b4b4aa0..f6a14e5 100644
--- a/src/misc/Makefile.in
+++ b/src/misc/Makefile.in
@@ -193,6 +193,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/platform/Makefile.in b/src/platform/Makefile.in
index a1a995c..3e53cef 100644
--- a/src/platform/Makefile.in
+++ b/src/platform/Makefile.in
@@ -205,6 +205,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/platform/visualc/Makefile.in b/src/platform/visualc/Makefile.in
index 6d85dbd..33ed846 100644
--- a/src/platform/visualc/Makefile.in
+++ b/src/platform/visualc/Makefile.in
@@ -145,6 +145,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/platform/visualc/config.h b/src/platform/visualc/config.h
index 702f962..7af9464 100644
--- a/src/platform/visualc/config.h
+++ b/src/platform/visualc/config.h
@@ -6,6 +6,10 @@
 /* Define to 1 to enable screenshots, requires libpng */
 #define C_SSHOT 1
 
+#if C_SSHOT
+#define C_LIBPNG
+#endif
+
 /* Define to 1 to use opengl display output support */
 #define C_OPENGL 1
 
@@ -52,6 +56,10 @@
 /* Define to 1 if you want serial passthrough support (Win32 only). */
 #define C_DIRECTSERIAL 1
 
+#define C_DIRECTLPT 1
+
+#define C_PRINTER 1
+
 #define GCC_ATTRIBUTE(x) /* attribute not supported */
 #define GCC_UNLIKELY(x) (x)
 #define GCC_LIKELY(x) (x)
diff --git a/src/shell/Makefile.in b/src/shell/Makefile.in
index 8c7e4b5..3ee7973 100644
--- a/src/shell/Makefile.in
+++ b/src/shell/Makefile.in
@@ -193,6 +193,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/src/shell/shell.cpp b/src/shell/shell.cpp
index 8f379b2..ab15359 100644
--- a/src/shell/shell.cpp
+++ b/src/shell/shell.cpp
@@ -633,7 +633,7 @@ void SHELL_Init() {
 	DOS_ForceDuplicateEntry(1,0);				/* "new" STDIN */
 	DOS_ForceDuplicateEntry(1,2);				/* STDERR */
 	DOS_OpenFile("CON",OPEN_READWRITE,&dummy);	/* STDAUX */
-	DOS_OpenFile("CON",OPEN_READWRITE,&dummy);	/* STDPRN */
+	DOS_OpenFile("PRN",OPEN_READWRITE,&dummy);	/* STDPRN */
 
 	psp.SetParent(psp_seg);
 	/* Set the environment */
diff --git a/visualc_net/Makefile.in b/visualc_net/Makefile.in
index 7211fd5..a699379 100644
--- a/visualc_net/Makefile.in
+++ b/visualc_net/Makefile.in
@@ -145,6 +145,7 @@ ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 GREP = @GREP@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff --git a/visualc_net/dosbox.vcproj b/visualc_net/dosbox.vcproj
index 5a36f2e..f7a9c05 100644
--- a/visualc_net/dosbox.vcproj
+++ b/visualc_net/dosbox.vcproj
@@ -606,6 +606,52 @@
 						RelativePath="..\src\hardware\serialport\softmodem.h">
 					</File>
 				</Filter>
+				<Filter
+					Name="parport"
+					Filter="">
+					<File
+						RelativePath="..\src\hardware\parport\directlpt_linux.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\directlpt_linux.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\directlpt_win32.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\directlpt_win32.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\filelpt.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\filelpt.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\parport.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer_charmaps.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer_charmaps.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer_if.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer_redir.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer_redir.h">
+					</File>
+				</Filter>
 			</Filter>
 			<Filter
 				Name="gui"
@@ -761,6 +807,23 @@
 					RelativePath="..\src\fpu\fpu_instructions_x86.h">
 				</File>
 			</Filter>
+			<Filter
+				Name="libs"
+				Filter="">
+				<Filter
+					Name="porttalk"
+					Filter="">
+					<File
+						RelativePath="..\src\libs\porttalk\porttalk.cpp">
+					</File>
+					<File
+						RelativePath="..\src\libs\porttalk\porttalk.h">
+					</File>
+					<File
+						RelativePath="..\src\libs\porttalk\PortTalk_IOCTL.h">
+					</File>
+				</Filter>
+			</Filter>
 		</Filter>
 		<Filter
 			Name="Header Files"
@@ -832,6 +895,9 @@
 				RelativePath="..\include\paging.h">
 			</File>
 			<File
+				RelativePath="..\include\parport.h">
+			</File>
+			<File
 				RelativePath="..\include\pic.h">
 			</File>
 			<File
